function ue(e){if(!Number.isSafeInteger(e)||e<0)throw new Error("positive integer expected, got "+e)}function $e(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function Rt(e,...n){if(!$e(e))throw new Error("Uint8Array expected");if(n.length>0&&!n.includes(e.length))throw new Error("Uint8Array expected of length "+n+", got length="+e.length)}function Xe(e){if(typeof e!="function"||typeof e.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");ue(e.outputLen),ue(e.blockLen)}function qt(e,n=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(n&&e.finished)throw new Error("Hash#digest() has already been called")}function We(e,n){Rt(e);const t=n.outputLen;if(e.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}const Et=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Ft(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}function it(e,n){return e<<32-n|e>>>n}function Pe(e){if(typeof e!="string")throw new Error("utf8ToBytes expected string, got "+typeof e);return new Uint8Array(new TextEncoder().encode(e))}function Jt(e){return typeof e=="string"&&(e=Pe(e)),Rt(e),e}function Qe(...e){let n=0;for(let r=0;r<e.length;r++){const o=e[r];Rt(o),n+=o.length}const t=new Uint8Array(n);for(let r=0,o=0;r<e.length;r++){const s=e[r];t.set(s,o),o+=s.length}return t}class Se{clone(){return this._cloneInto()}}function Ae(e){const n=r=>e().update(Jt(r)).digest(),t=e();return n.outputLen=t.outputLen,n.blockLen=t.blockLen,n.create=()=>e(),n}function ve(e=32){if(Et&&typeof Et.getRandomValues=="function")return Et.getRandomValues(new Uint8Array(e));if(Et&&typeof Et.randomBytes=="function")return Et.randomBytes(e);throw new Error("crypto.getRandomValues must be defined")}function Je(e,n,t,r){if(typeof e.setBigUint64=="function")return e.setBigUint64(n,t,r);const o=BigInt(32),s=BigInt(4294967295),c=Number(t>>o&s),f=Number(t&s),i=r?4:0,d=r?0:4;e.setUint32(n+i,c,r),e.setUint32(n+d,f,r)}function tn(e,n,t){return e&n^~e&t}function en(e,n,t){return e&n^e&t^n&t}class Ie extends Se{constructor(n,t,r,o){super(),this.blockLen=n,this.outputLen=t,this.padOffset=r,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(n),this.view=Ft(this.buffer)}update(n){qt(this);const{view:t,buffer:r,blockLen:o}=this;n=Jt(n);const s=n.length;for(let c=0;c<s;){const f=Math.min(o-this.pos,s-c);if(f===o){const i=Ft(n);for(;o<=s-c;c+=o)this.process(i,c);continue}r.set(n.subarray(c,c+f),this.pos),this.pos+=f,c+=f,this.pos===o&&(this.process(t,0),this.pos=0)}return this.length+=n.length,this.roundClean(),this}digestInto(n){qt(this),We(n,this),this.finished=!0;const{buffer:t,view:r,blockLen:o,isLE:s}=this;let{pos:c}=this;t[c++]=128,this.buffer.subarray(c).fill(0),this.padOffset>o-c&&(this.process(r,0),c=0);for(let b=c;b<o;b++)t[b]=0;Je(r,o-8,BigInt(this.length*8),s),this.process(r,0);const f=Ft(n),i=this.outputLen;if(i%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const d=i/4,a=this.get();if(d>a.length)throw new Error("_sha2: outputLen bigger than state");for(let b=0;b<d;b++)f.setUint32(4*b,a[b],s)}digest(){const{buffer:n,outputLen:t}=this;this.digestInto(n);const r=n.slice(0,t);return this.destroy(),r}_cloneInto(n){n||(n=new this.constructor),n.set(...this.get());const{blockLen:t,buffer:r,length:o,finished:s,destroyed:c,pos:f}=this;return n.length=o,n.pos=f,n.finished=s,n.destroyed=c,o%t&&n.buffer.set(r),n}}const _t=BigInt(2**32-1),$t=BigInt(32);function He(e,n=!1){return n?{h:Number(e&_t),l:Number(e>>$t&_t)}:{h:Number(e>>$t&_t)|0,l:Number(e&_t)|0}}function nn(e,n=!1){let t=new Uint32Array(e.length),r=new Uint32Array(e.length);for(let o=0;o<e.length;o++){const{h:s,l:c}=He(e[o],n);[t[o],r[o]]=[s,c]}return[t,r]}const rn=(e,n)=>BigInt(e>>>0)<<$t|BigInt(n>>>0),on=(e,n,t)=>e>>>t,sn=(e,n,t)=>e<<32-t|n>>>t,cn=(e,n,t)=>e>>>t|n<<32-t,fn=(e,n,t)=>e<<32-t|n>>>t,an=(e,n,t)=>e<<64-t|n>>>t-32,ln=(e,n,t)=>e>>>t-32|n<<64-t,un=(e,n)=>n,dn=(e,n)=>e,hn=(e,n,t)=>e<<t|n>>>32-t,wn=(e,n,t)=>n<<t|e>>>32-t,gn=(e,n,t)=>n<<t-32|e>>>64-t,bn=(e,n,t)=>e<<t-32|n>>>64-t;function xn(e,n,t,r){const o=(n>>>0)+(r>>>0);return{h:e+t+(o/2**32|0)|0,l:o|0}}const pn=(e,n,t)=>(e>>>0)+(n>>>0)+(t>>>0),yn=(e,n,t,r)=>n+t+r+(e/2**32|0)|0,mn=(e,n,t,r)=>(e>>>0)+(n>>>0)+(t>>>0)+(r>>>0),Bn=(e,n,t,r,o)=>n+t+r+o+(e/2**32|0)|0,En=(e,n,t,r,o)=>(e>>>0)+(n>>>0)+(t>>>0)+(r>>>0)+(o>>>0),Sn=(e,n,t,r,o,s)=>n+t+r+o+s+(e/2**32|0)|0,R={fromBig:He,split:nn,toBig:rn,shrSH:on,shrSL:sn,rotrSH:cn,rotrSL:fn,rotrBH:an,rotrBL:ln,rotr32H:un,rotr32L:dn,rotlSH:hn,rotlSL:wn,rotlBH:gn,rotlBL:bn,add:xn,add3L:pn,add3H:yn,add4L:mn,add4H:Bn,add5H:Sn,add5L:En},[An,vn]=R.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(e=>BigInt(e))),ht=new Uint32Array(80),wt=new Uint32Array(80);class In extends Ie{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:n,Al:t,Bh:r,Bl:o,Ch:s,Cl:c,Dh:f,Dl:i,Eh:d,El:a,Fh:b,Fl:g,Gh:E,Gl:I,Hh:p,Hl:u}=this;return[n,t,r,o,s,c,f,i,d,a,b,g,E,I,p,u]}set(n,t,r,o,s,c,f,i,d,a,b,g,E,I,p,u){this.Ah=n|0,this.Al=t|0,this.Bh=r|0,this.Bl=o|0,this.Ch=s|0,this.Cl=c|0,this.Dh=f|0,this.Dl=i|0,this.Eh=d|0,this.El=a|0,this.Fh=b|0,this.Fl=g|0,this.Gh=E|0,this.Gl=I|0,this.Hh=p|0,this.Hl=u|0}process(n,t){for(let w=0;w<16;w++,t+=4)ht[w]=n.getUint32(t),wt[w]=n.getUint32(t+=4);for(let w=16;w<80;w++){const O=ht[w-15]|0,q=wt[w-15]|0,U=R.rotrSH(O,q,1)^R.rotrSH(O,q,8)^R.shrSH(O,q,7),H=R.rotrSL(O,q,1)^R.rotrSL(O,q,8)^R.shrSL(O,q,7),L=ht[w-2]|0,A=wt[w-2]|0,Y=R.rotrSH(L,A,19)^R.rotrBH(L,A,61)^R.shrSH(L,A,6),k=R.rotrSL(L,A,19)^R.rotrBL(L,A,61)^R.shrSL(L,A,6),Z=R.add4L(H,k,wt[w-7],wt[w-16]),K=R.add4H(Z,U,Y,ht[w-7],ht[w-16]);ht[w]=K|0,wt[w]=Z|0}let{Ah:r,Al:o,Bh:s,Bl:c,Ch:f,Cl:i,Dh:d,Dl:a,Eh:b,El:g,Fh:E,Fl:I,Gh:p,Gl:u,Hh:m,Hl:v}=this;for(let w=0;w<80;w++){const O=R.rotrSH(b,g,14)^R.rotrSH(b,g,18)^R.rotrBH(b,g,41),q=R.rotrSL(b,g,14)^R.rotrSL(b,g,18)^R.rotrBL(b,g,41),U=b&E^~b&p,H=g&I^~g&u,L=R.add5L(v,q,H,vn[w],wt[w]),A=R.add5H(L,m,O,U,An[w],ht[w]),Y=L|0,k=R.rotrSH(r,o,28)^R.rotrBH(r,o,34)^R.rotrBH(r,o,39),Z=R.rotrSL(r,o,28)^R.rotrBL(r,o,34)^R.rotrBL(r,o,39),K=r&s^r&f^s&f,y=o&c^o&i^c&i;m=p|0,v=u|0,p=E|0,u=I|0,E=b|0,I=g|0,{h:b,l:g}=R.add(d|0,a|0,A|0,Y|0),d=f|0,a=i|0,f=s|0,i=c|0,s=r|0,c=o|0;const S=R.add3L(Y,Z,y);r=R.add3H(S,A,k,K),o=S|0}({h:r,l:o}=R.add(this.Ah|0,this.Al|0,r|0,o|0)),{h:s,l:c}=R.add(this.Bh|0,this.Bl|0,s|0,c|0),{h:f,l:i}=R.add(this.Ch|0,this.Cl|0,f|0,i|0),{h:d,l:a}=R.add(this.Dh|0,this.Dl|0,d|0,a|0),{h:b,l:g}=R.add(this.Eh|0,this.El|0,b|0,g|0),{h:E,l:I}=R.add(this.Fh|0,this.Fl|0,E|0,I|0),{h:p,l:u}=R.add(this.Gh|0,this.Gl|0,p|0,u|0),{h:m,l:v}=R.add(this.Hh|0,this.Hl|0,m|0,v|0),this.set(r,o,s,c,f,i,d,a,b,g,E,I,p,u,m,v)}roundClean(){ht.fill(0),wt.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const Hn=Ae(()=>new In);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ct=BigInt(0),Zt=BigInt(1),Ln=BigInt(2);function yt(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function Nt(e){if(!yt(e))throw new Error("Uint8Array expected")}function ut(e,n){if(typeof n!="boolean")throw new Error(e+" boolean expected, got "+n)}const On=Array.from({length:256},(e,n)=>n.toString(16).padStart(2,"0"));function mt(e){Nt(e);let n="";for(let t=0;t<e.length;t++)n+=On[e[t]];return n}function St(e){const n=e.toString(16);return n.length&1?"0"+n:n}function te(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);return e===""?Ct:BigInt("0x"+e)}const ft={_0:48,_9:57,A:65,F:70,a:97,f:102};function de(e){if(e>=ft._0&&e<=ft._9)return e-ft._0;if(e>=ft.A&&e<=ft.F)return e-(ft.A-10);if(e>=ft.a&&e<=ft.f)return e-(ft.a-10)}function vt(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);const n=e.length,t=n/2;if(n%2)throw new Error("hex string expected, got unpadded hex of length "+n);const r=new Uint8Array(t);for(let o=0,s=0;o<t;o++,s+=2){const c=de(e.charCodeAt(s)),f=de(e.charCodeAt(s+1));if(c===void 0||f===void 0){const i=e[s]+e[s+1];throw new Error('hex string expected, got non-hex character "'+i+'" at index '+s)}r[o]=c*16+f}return r}function pt(e){return te(mt(e))}function At(e){return Nt(e),te(mt(Uint8Array.from(e).reverse()))}function It(e,n){return vt(e.toString(16).padStart(n*2,"0"))}function Lt(e,n){return It(e,n).reverse()}function Nn(e){return vt(St(e))}function j(e,n,t){let r;if(typeof n=="string")try{r=vt(n)}catch(s){throw new Error(e+" must be hex string or Uint8Array, cause: "+s)}else if(yt(n))r=Uint8Array.from(n);else throw new Error(e+" must be hex string or Uint8Array");const o=r.length;if(typeof t=="number"&&o!==t)throw new Error(e+" of length "+t+" expected, got "+o);return r}function Bt(...e){let n=0;for(let r=0;r<e.length;r++){const o=e[r];Nt(o),n+=o.length}const t=new Uint8Array(n);for(let r=0,o=0;r<e.length;r++){const s=e[r];t.set(s,o),o+=s.length}return t}function _n(e,n){if(e.length!==n.length)return!1;let t=0;for(let r=0;r<e.length;r++)t|=e[r]^n[r];return t===0}function Un(e){if(typeof e!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(e))}const Yt=e=>typeof e=="bigint"&&Ct<=e;function zt(e,n,t){return Yt(e)&&Yt(n)&&Yt(t)&&n<=e&&e<t}function rt(e,n,t,r){if(!zt(n,t,r))throw new Error("expected valid "+e+": "+t+" <= n < "+r+", got "+n)}function Le(e){let n;for(n=0;e>Ct;e>>=Zt,n+=1);return n}function Tn(e,n){return e>>BigInt(n)&Zt}function qn(e,n,t){return e|(t?Zt:Ct)<<BigInt(n)}const ee=e=>(Ln<<BigInt(e-1))-Zt,Mt=e=>new Uint8Array(e),he=e=>Uint8Array.from(e);function Oe(e,n,t){if(typeof e!="number"||e<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let r=Mt(e),o=Mt(e),s=0;const c=()=>{r.fill(1),o.fill(0),s=0},f=(...b)=>t(o,r,...b),i=(b=Mt())=>{o=f(he([0]),b),r=f(),b.length!==0&&(o=f(he([1]),b),r=f())},d=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let b=0;const g=[];for(;b<n;){r=f();const E=r.slice();g.push(E),b+=r.length}return Bt(...g)};return(b,g)=>{c(),i(b);let E;for(;!(E=g(d()));)i();return c(),E}}const Rn={bigint:e=>typeof e=="bigint",function:e=>typeof e=="function",boolean:e=>typeof e=="boolean",string:e=>typeof e=="string",stringOrUint8Array:e=>typeof e=="string"||yt(e),isSafeInteger:e=>Number.isSafeInteger(e),array:e=>Array.isArray(e),field:(e,n)=>n.Fp.isValid(e),hash:e=>typeof e=="function"&&Number.isSafeInteger(e.outputLen)};function Ht(e,n,t={}){const r=(o,s,c)=>{const f=Rn[s];if(typeof f!="function")throw new Error("invalid validator function");const i=e[o];if(!(c&&i===void 0)&&!f(i,e))throw new Error("param "+String(o)+" is invalid. Expected "+s+", got "+i)};for(const[o,s]of Object.entries(n))r(o,s,!1);for(const[o,s]of Object.entries(t))r(o,s,!0);return e}const Cn=()=>{throw new Error("not implemented")};function Ot(e){const n=new WeakMap;return(t,...r)=>{const o=n.get(t);if(o!==void 0)return o;const s=e(t,...r);return n.set(t,s),s}}const Zn=Object.freeze(Object.defineProperty({__proto__:null,aInRange:rt,abool:ut,abytes:Nt,bitGet:Tn,bitLen:Le,bitMask:ee,bitSet:qn,bytesToHex:mt,bytesToNumberBE:pt,bytesToNumberLE:At,concatBytes:Bt,createHmacDrbg:Oe,ensureBytes:j,equalBytes:_n,hexToBytes:vt,hexToNumber:te,inRange:zt,isBytes:yt,memoized:Ot,notImplemented:Cn,numberToBytesBE:It,numberToBytesLE:Lt,numberToHexUnpadded:St,numberToVarBytesBE:Nn,utf8ToBytes:Un,validateObject:Ht},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const P=BigInt(0),G=BigInt(1),xt=BigInt(2),zn=BigInt(3),Xt=BigInt(4),we=BigInt(5),ge=BigInt(8);function M(e,n){const t=e%n;return t>=P?t:n+t}function kn(e,n,t){if(n<P)throw new Error("invalid exponent, negatives unsupported");if(t<=P)throw new Error("invalid modulus");if(t===G)return P;let r=G;for(;n>P;)n&G&&(r=r*e%t),e=e*e%t,n>>=G;return r}function D(e,n,t){let r=e;for(;n-- >P;)r*=r,r%=t;return r}function Wt(e,n){if(e===P)throw new Error("invert: expected non-zero number");if(n<=P)throw new Error("invert: expected positive modulus, got "+n);let t=M(e,n),r=n,o=P,s=G;for(;t!==P;){const f=r/t,i=r%t,d=o-s*f;r=t,t=i,o=s,s=d}if(r!==G)throw new Error("invert: does not exist");return M(o,n)}function Vn(e){const n=(e-G)/xt;let t,r,o;for(t=e-G,r=0;t%xt===P;t/=xt,r++);for(o=xt;o<e&&kn(o,n,e)!==e-G;o++)if(o>1e3)throw new Error("Cannot find square root: likely non-prime P");if(r===1){const c=(e+G)/Xt;return function(i,d){const a=i.pow(d,c);if(!i.eql(i.sqr(a),d))throw new Error("Cannot find square root");return a}}const s=(t+G)/xt;return function(f,i){if(f.pow(i,n)===f.neg(f.ONE))throw new Error("Cannot find square root");let d=r,a=f.pow(f.mul(f.ONE,o),t),b=f.pow(i,s),g=f.pow(i,t);for(;!f.eql(g,f.ONE);){if(f.eql(g,f.ZERO))return f.ZERO;let E=1;for(let p=f.sqr(g);E<d&&!f.eql(p,f.ONE);E++)p=f.sqr(p);const I=f.pow(a,G<<BigInt(d-E-1));a=f.sqr(I),b=f.mul(b,I),g=f.mul(g,a),d=E}return b}}function Fn(e){if(e%Xt===zn){const n=(e+G)/Xt;return function(r,o){const s=r.pow(o,n);if(!r.eql(r.sqr(s),o))throw new Error("Cannot find square root");return s}}if(e%ge===we){const n=(e-we)/ge;return function(r,o){const s=r.mul(o,xt),c=r.pow(s,n),f=r.mul(o,c),i=r.mul(r.mul(f,xt),c),d=r.mul(f,r.sub(i,r.ONE));if(!r.eql(r.sqr(d),o))throw new Error("Cannot find square root");return d}}return Vn(e)}const Yn=(e,n)=>(M(e,n)&G)===G,Mn=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Gn(e){const n={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=Mn.reduce((r,o)=>(r[o]="function",r),n);return Ht(e,t)}function Dn(e,n,t){if(t<P)throw new Error("invalid exponent, negatives unsupported");if(t===P)return e.ONE;if(t===G)return n;let r=e.ONE,o=n;for(;t>P;)t&G&&(r=e.mul(r,o)),o=e.sqr(o),t>>=G;return r}function jn(e,n){const t=new Array(n.length),r=n.reduce((s,c,f)=>e.is0(c)?s:(t[f]=s,e.mul(s,c)),e.ONE),o=e.inv(r);return n.reduceRight((s,c,f)=>e.is0(c)?s:(t[f]=e.mul(s,t[f]),e.mul(s,c)),o),t}function Ne(e,n){const t=n!==void 0?n:e.toString(2).length,r=Math.ceil(t/8);return{nBitLength:t,nByteLength:r}}function kt(e,n,t=!1,r={}){if(e<=P)throw new Error("invalid field: expected ORDER > 0, got "+e);const{nBitLength:o,nByteLength:s}=Ne(e,n);if(s>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let c;const f=Object.freeze({ORDER:e,isLE:t,BITS:o,BYTES:s,MASK:ee(o),ZERO:P,ONE:G,create:i=>M(i,e),isValid:i=>{if(typeof i!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof i);return P<=i&&i<e},is0:i=>i===P,isOdd:i=>(i&G)===G,neg:i=>M(-i,e),eql:(i,d)=>i===d,sqr:i=>M(i*i,e),add:(i,d)=>M(i+d,e),sub:(i,d)=>M(i-d,e),mul:(i,d)=>M(i*d,e),pow:(i,d)=>Dn(f,i,d),div:(i,d)=>M(i*Wt(d,e),e),sqrN:i=>i*i,addN:(i,d)=>i+d,subN:(i,d)=>i-d,mulN:(i,d)=>i*d,inv:i=>Wt(i,e),sqrt:r.sqrt||(i=>(c||(c=Fn(e)),c(f,i))),invertBatch:i=>jn(f,i),cmov:(i,d,a)=>a?d:i,toBytes:i=>t?Lt(i,s):It(i,s),fromBytes:i=>{if(i.length!==s)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+i.length);return t?At(i):pt(i)}});return Object.freeze(f)}function _e(e){if(typeof e!="bigint")throw new Error("field order must be bigint");const n=e.toString(2).length;return Math.ceil(n/8)}function Ue(e){const n=_e(e);return n+Math.ceil(n/2)}function Kn(e,n,t=!1){const r=e.length,o=_e(n),s=Ue(n);if(r<16||r<s||r>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+r);const c=t?At(e):pt(e),f=M(c,n-G)+G;return t?Lt(f,o):It(f,o)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const be=BigInt(0),Ut=BigInt(1);function Gt(e,n){const t=n.negate();return e?t:n}function Te(e,n){if(!Number.isSafeInteger(e)||e<=0||e>n)throw new Error("invalid window size, expected [1.."+n+"], got W="+e)}function Dt(e,n){Te(e,n);const t=Math.ceil(n/e)+1,r=2**(e-1);return{windows:t,windowSize:r}}function $n(e,n){if(!Array.isArray(e))throw new Error("array expected");e.forEach((t,r)=>{if(!(t instanceof n))throw new Error("invalid point at index "+r)})}function Xn(e,n){if(!Array.isArray(e))throw new Error("array of scalars expected");e.forEach((t,r)=>{if(!n.isValid(t))throw new Error("invalid scalar at index "+r)})}const jt=new WeakMap,qe=new WeakMap;function Kt(e){return qe.get(e)||1}function Re(e,n){return{constTimeNegate:Gt,hasPrecomputes(t){return Kt(t)!==1},unsafeLadder(t,r,o=e.ZERO){let s=t;for(;r>be;)r&Ut&&(o=o.add(s)),s=s.double(),r>>=Ut;return o},precomputeWindow(t,r){const{windows:o,windowSize:s}=Dt(r,n),c=[];let f=t,i=f;for(let d=0;d<o;d++){i=f,c.push(i);for(let a=1;a<s;a++)i=i.add(f),c.push(i);f=i.double()}return c},wNAF(t,r,o){const{windows:s,windowSize:c}=Dt(t,n);let f=e.ZERO,i=e.BASE;const d=BigInt(2**t-1),a=2**t,b=BigInt(t);for(let g=0;g<s;g++){const E=g*c;let I=Number(o&d);o>>=b,I>c&&(I-=a,o+=Ut);const p=E,u=E+Math.abs(I)-1,m=g%2!==0,v=I<0;I===0?i=i.add(Gt(m,r[p])):f=f.add(Gt(v,r[u]))}return{p:f,f:i}},wNAFUnsafe(t,r,o,s=e.ZERO){const{windows:c,windowSize:f}=Dt(t,n),i=BigInt(2**t-1),d=2**t,a=BigInt(t);for(let b=0;b<c;b++){const g=b*f;if(o===be)break;let E=Number(o&i);if(o>>=a,E>f&&(E-=d,o+=Ut),E===0)continue;let I=r[g+Math.abs(E)-1];E<0&&(I=I.negate()),s=s.add(I)}return s},getPrecomputes(t,r,o){let s=jt.get(r);return s||(s=this.precomputeWindow(r,t),t!==1&&jt.set(r,o(s))),s},wNAFCached(t,r,o){const s=Kt(t);return this.wNAF(s,this.getPrecomputes(s,t,o),r)},wNAFCachedUnsafe(t,r,o,s){const c=Kt(t);return c===1?this.unsafeLadder(t,r,s):this.wNAFUnsafe(c,this.getPrecomputes(c,t,o),r,s)},setWindowSize(t,r){Te(r,n),qe.set(t,r),jt.delete(t)}}}function Ce(e,n,t,r){if($n(t,e),Xn(r,n),t.length!==r.length)throw new Error("arrays of points and scalars must have equal length");const o=e.ZERO,s=Le(BigInt(t.length)),c=s>12?s-3:s>4?s-2:s?2:1,f=(1<<c)-1,i=new Array(f+1).fill(o),d=Math.floor((n.BITS-1)/c)*c;let a=o;for(let b=d;b>=0;b-=c){i.fill(o);for(let E=0;E<r.length;E++){const I=r[E],p=Number(I>>BigInt(b)&BigInt(f));i[p]=i[p].add(t[E])}let g=o;for(let E=i.length-1,I=o;E>0;E--)I=I.add(i[E]),g=g.add(I);if(a=a.add(g),b!==0)for(let E=0;E<c;E++)a=a.double()}return a}function ne(e){return Gn(e.Fp),Ht(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Ne(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ot=BigInt(0),nt=BigInt(1),Tt=BigInt(2),Wn=BigInt(8),Pn={zip215:!0};function Qn(e){const n=ne(e);return Ht(e,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...n})}function Jn(e){const n=Qn(e),{Fp:t,n:r,prehash:o,hash:s,randomBytes:c,nByteLength:f,h:i}=n,d=Tt<<BigInt(f*8)-nt,a=t.create,b=kt(n.n,n.nBitLength),g=n.uvRatio||((h,l)=>{try{return{isValid:!0,value:t.sqrt(h*t.inv(l))}}catch{return{isValid:!1,value:ot}}}),E=n.adjustScalarBytes||(h=>h),I=n.domain||((h,l,x)=>{if(ut("phflag",x),l.length||x)throw new Error("Contexts/pre-hash are not supported");return h});function p(h,l){rt("coordinate "+h,l,ot,d)}function u(h){if(!(h instanceof w))throw new Error("ExtendedPoint expected")}const m=Ot((h,l)=>{const{ex:x,ey:B,ez:N}=h,_=h.is0();l==null&&(l=_?Wn:t.inv(N));const C=a(x*l),z=a(B*l),T=a(N*l);if(_)return{x:ot,y:nt};if(T!==nt)throw new Error("invZ was invalid");return{x:C,y:z}}),v=Ot(h=>{const{a:l,d:x}=n;if(h.is0())throw new Error("bad point: ZERO");const{ex:B,ey:N,ez:_,et:C}=h,z=a(B*B),T=a(N*N),V=a(_*_),F=a(V*V),$=a(z*l),X=a(V*a($+T)),Q=a(F+a(x*a(z*T)));if(X!==Q)throw new Error("bad point: equation left != right (1)");const J=a(B*N),et=a(_*C);if(J!==et)throw new Error("bad point: equation left != right (2)");return!0});class w{constructor(l,x,B,N){this.ex=l,this.ey=x,this.ez=B,this.et=N,p("x",l),p("y",x),p("z",B),p("t",N),Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(l){if(l instanceof w)throw new Error("extended point not allowed");const{x,y:B}=l||{};return p("x",x),p("y",B),new w(x,B,nt,a(x*B))}static normalizeZ(l){const x=t.invertBatch(l.map(B=>B.ez));return l.map((B,N)=>B.toAffine(x[N])).map(w.fromAffine)}static msm(l,x){return Ce(w,b,l,x)}_setWindowSize(l){U.setWindowSize(this,l)}assertValidity(){v(this)}equals(l){u(l);const{ex:x,ey:B,ez:N}=this,{ex:_,ey:C,ez:z}=l,T=a(x*z),V=a(_*N),F=a(B*z),$=a(C*N);return T===V&&F===$}is0(){return this.equals(w.ZERO)}negate(){return new w(a(-this.ex),this.ey,this.ez,a(-this.et))}double(){const{a:l}=n,{ex:x,ey:B,ez:N}=this,_=a(x*x),C=a(B*B),z=a(Tt*a(N*N)),T=a(l*_),V=x+B,F=a(a(V*V)-_-C),$=T+C,X=$-z,Q=T-C,J=a(F*X),et=a($*Q),tt=a(F*Q),st=a(X*$);return new w(J,et,st,tt)}add(l){u(l);const{a:x,d:B}=n,{ex:N,ey:_,ez:C,et:z}=this,{ex:T,ey:V,ez:F,et:$}=l;if(x===BigInt(-1)){const oe=a((_-N)*(V+T)),se=a((_+N)*(V-T)),Vt=a(se-oe);if(Vt===ot)return this.double();const ie=a(C*Tt*$),ce=a(z*Tt*F),fe=ce+ie,ae=se+oe,le=ce-ie,Ge=a(fe*Vt),De=a(ae*le),je=a(fe*le),Ke=a(Vt*ae);return new w(Ge,De,Ke,je)}const X=a(N*T),Q=a(_*V),J=a(z*B*$),et=a(C*F),tt=a((N+_)*(T+V)-X-Q),st=et-J,dt=et+J,ct=a(Q-x*X),Ve=a(tt*st),Fe=a(dt*ct),Ye=a(tt*ct),Me=a(st*dt);return new w(Ve,Fe,Me,Ye)}subtract(l){return this.add(l.negate())}wNAF(l){return U.wNAFCached(this,l,w.normalizeZ)}multiply(l){const x=l;rt("scalar",x,nt,r);const{p:B,f:N}=this.wNAF(x);return w.normalizeZ([B,N])[0]}multiplyUnsafe(l,x=w.ZERO){const B=l;return rt("scalar",B,ot,r),B===ot?q:this.is0()||B===nt?this:U.wNAFCachedUnsafe(this,B,w.normalizeZ,x)}isSmallOrder(){return this.multiplyUnsafe(i).is0()}isTorsionFree(){return U.unsafeLadder(this,r).is0()}toAffine(l){return m(this,l)}clearCofactor(){const{h:l}=n;return l===nt?this:this.multiplyUnsafe(l)}static fromHex(l,x=!1){const{d:B,a:N}=n,_=t.BYTES;l=j("pointHex",l,_),ut("zip215",x);const C=l.slice(),z=l[_-1];C[_-1]=z&-129;const T=At(C),V=x?d:t.ORDER;rt("pointHex.y",T,ot,V);const F=a(T*T),$=a(F-nt),X=a(B*F-N);let{isValid:Q,value:J}=g($,X);if(!Q)throw new Error("Point.fromHex: invalid y coordinate");const et=(J&nt)===nt,tt=(z&128)!==0;if(!x&&J===ot&&tt)throw new Error("Point.fromHex: x=0 and x_0=1");return tt!==et&&(J=a(-J)),w.fromAffine({x:J,y:T})}static fromPrivateKey(l){return A(l).point}toRawBytes(){const{x:l,y:x}=this.toAffine(),B=Lt(x,t.BYTES);return B[B.length-1]|=l&nt?128:0,B}toHex(){return mt(this.toRawBytes())}}w.BASE=new w(n.Gx,n.Gy,nt,a(n.Gx*n.Gy)),w.ZERO=new w(ot,nt,nt,ot);const{BASE:O,ZERO:q}=w,U=Re(w,f*8);function H(h){return M(h,r)}function L(h){return H(At(h))}function A(h){const l=t.BYTES;h=j("private key",h,l);const x=j("hashed private key",s(h),2*l),B=E(x.slice(0,l)),N=x.slice(l,2*l),_=L(B),C=O.multiply(_),z=C.toRawBytes();return{head:B,prefix:N,scalar:_,point:C,pointBytes:z}}function Y(h){return A(h).pointBytes}function k(h=new Uint8Array,...l){const x=Bt(...l);return L(s(I(x,j("context",h),!!o)))}function Z(h,l,x={}){h=j("message",h),o&&(h=o(h));const{prefix:B,scalar:N,pointBytes:_}=A(l),C=k(x.context,B,h),z=O.multiply(C).toRawBytes(),T=k(x.context,z,_,h),V=H(C+T*N);rt("signature.s",V,ot,r);const F=Bt(z,Lt(V,t.BYTES));return j("result",F,t.BYTES*2)}const K=Pn;function y(h,l,x,B=K){const{context:N,zip215:_}=B,C=t.BYTES;h=j("signature",h,2*C),l=j("message",l),x=j("publicKey",x,C),_!==void 0&&ut("zip215",_),o&&(l=o(l));const z=At(h.slice(C,2*C));let T,V,F;try{T=w.fromHex(x,_),V=w.fromHex(h.slice(0,C),_),F=O.multiplyUnsafe(z)}catch{return!1}if(!_&&T.isSmallOrder())return!1;const $=k(N,V.toRawBytes(),T.toRawBytes(),l);return V.add(T.multiplyUnsafe($)).subtract(F).clearCofactor().equals(w.ZERO)}return O._setWindowSize(8),{CURVE:n,getPublicKey:Y,sign:Z,verify:y,ExtendedPoint:w,utils:{getExtendedPublicKey:A,randomPrivateKey:()=>c(t.BYTES),precompute(h=8,l=w.BASE){return l._setWindowSize(h),l.multiply(BigInt(3)),l}}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const re=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),xe=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");BigInt(0);const tr=BigInt(1),pe=BigInt(2);BigInt(3);const er=BigInt(5),nr=BigInt(8);function rr(e){const n=BigInt(10),t=BigInt(20),r=BigInt(40),o=BigInt(80),s=re,f=e*e%s*e%s,i=D(f,pe,s)*f%s,d=D(i,tr,s)*e%s,a=D(d,er,s)*d%s,b=D(a,n,s)*a%s,g=D(b,t,s)*b%s,E=D(g,r,s)*g%s,I=D(E,o,s)*E%s,p=D(I,o,s)*E%s,u=D(p,n,s)*a%s;return{pow_p_5_8:D(u,pe,s)*e%s,b2:f}}function or(e){return e[0]&=248,e[31]&=127,e[31]|=64,e}function sr(e,n){const t=re,r=M(n*n*n,t),o=M(r*r*n,t),s=rr(e*o).pow_p_5_8;let c=M(e*r*s,t);const f=M(n*c*c,t),i=c,d=M(c*xe,t),a=f===e,b=f===M(-e,t),g=f===M(-e*xe,t);return a&&(c=i),(b||g)&&(c=d),Yn(c,t)&&(c=M(-c,t)),{isValid:a||b,value:c}}const ir=kt(re,void 0,!0),cr={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:ir,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:nr,Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:Hn,randomBytes:ve,adjustScalarBytes:or,uvRatio:sr},Er=Jn(cr),fr=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),gt=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),bt=new Uint32Array(64);class ar extends Ie{constructor(){super(64,32,8,!1),this.A=gt[0]|0,this.B=gt[1]|0,this.C=gt[2]|0,this.D=gt[3]|0,this.E=gt[4]|0,this.F=gt[5]|0,this.G=gt[6]|0,this.H=gt[7]|0}get(){const{A:n,B:t,C:r,D:o,E:s,F:c,G:f,H:i}=this;return[n,t,r,o,s,c,f,i]}set(n,t,r,o,s,c,f,i){this.A=n|0,this.B=t|0,this.C=r|0,this.D=o|0,this.E=s|0,this.F=c|0,this.G=f|0,this.H=i|0}process(n,t){for(let b=0;b<16;b++,t+=4)bt[b]=n.getUint32(t,!1);for(let b=16;b<64;b++){const g=bt[b-15],E=bt[b-2],I=it(g,7)^it(g,18)^g>>>3,p=it(E,17)^it(E,19)^E>>>10;bt[b]=p+bt[b-7]+I+bt[b-16]|0}let{A:r,B:o,C:s,D:c,E:f,F:i,G:d,H:a}=this;for(let b=0;b<64;b++){const g=it(f,6)^it(f,11)^it(f,25),E=a+g+tn(f,i,d)+fr[b]+bt[b]|0,p=(it(r,2)^it(r,13)^it(r,22))+en(r,o,s)|0;a=d,d=i,i=f,f=c+E|0,c=s,s=o,o=r,r=E+p|0}r=r+this.A|0,o=o+this.B|0,s=s+this.C|0,c=c+this.D|0,f=f+this.E|0,i=i+this.F|0,d=d+this.G|0,a=a+this.H|0,this.set(r,o,s,c,f,i,d,a)}roundClean(){bt.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const lr=Ae(()=>new ar);class Ze extends Se{constructor(n,t){super(),this.finished=!1,this.destroyed=!1,Xe(n);const r=Jt(t);if(this.iHash=n.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,s=new Uint8Array(o);s.set(r.length>o?n.create().update(r).digest():r);for(let c=0;c<s.length;c++)s[c]^=54;this.iHash.update(s),this.oHash=n.create();for(let c=0;c<s.length;c++)s[c]^=106;this.oHash.update(s),s.fill(0)}update(n){return qt(this),this.iHash.update(n),this}digestInto(n){qt(this),Rt(n,this.outputLen),this.finished=!0,this.iHash.digestInto(n),this.oHash.update(n),this.oHash.digestInto(n),this.destroy()}digest(){const n=new Uint8Array(this.oHash.outputLen);return this.digestInto(n),n}_cloneInto(n){n||(n=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:r,finished:o,destroyed:s,blockLen:c,outputLen:f}=this;return n=n,n.finished=o,n.destroyed=s,n.blockLen=c,n.outputLen=f,n.oHash=t._cloneInto(n.oHash),n.iHash=r._cloneInto(n.iHash),n}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const ze=(e,n,t)=>new Ze(e,n).update(t).digest();ze.create=(e,n)=>new Ze(e,n);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function ye(e){e.lowS!==void 0&&ut("lowS",e.lowS),e.prehash!==void 0&&ut("prehash",e.prehash)}function ur(e){const n=ne(e);Ht(n,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:t,Fp:r,a:o}=n;if(t){if(!r.eql(o,r.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...n})}const{bytesToNumberBE:dr,hexToBytes:hr}=Zn;class wr extends Error{constructor(n=""){super(n)}}const at={Err:wr,_tlv:{encode:(e,n)=>{const{Err:t}=at;if(e<0||e>256)throw new t("tlv.encode: wrong tag");if(n.length&1)throw new t("tlv.encode: unpadded data");const r=n.length/2,o=St(r);if(o.length/2&128)throw new t("tlv.encode: long form length too big");const s=r>127?St(o.length/2|128):"";return St(e)+s+o+n},decode(e,n){const{Err:t}=at;let r=0;if(e<0||e>256)throw new t("tlv.encode: wrong tag");if(n.length<2||n[r++]!==e)throw new t("tlv.decode: wrong tlv");const o=n[r++],s=!!(o&128);let c=0;if(!s)c=o;else{const i=o&127;if(!i)throw new t("tlv.decode(long): indefinite length not supported");if(i>4)throw new t("tlv.decode(long): byte length is too big");const d=n.subarray(r,r+i);if(d.length!==i)throw new t("tlv.decode: length bytes not complete");if(d[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const a of d)c=c<<8|a;if(r+=i,c<128)throw new t("tlv.decode(long): not minimal encoding")}const f=n.subarray(r,r+c);if(f.length!==c)throw new t("tlv.decode: wrong value length");return{v:f,l:n.subarray(r+c)}}},_int:{encode(e){const{Err:n}=at;if(e<lt)throw new n("integer: negative integers are not allowed");let t=St(e);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new n("unexpected DER parsing assertion: unpadded hex");return t},decode(e){const{Err:n}=at;if(e[0]&128)throw new n("invalid signature integer: negative");if(e[0]===0&&!(e[1]&128))throw new n("invalid signature integer: unnecessary leading zero");return dr(e)}},toSig(e){const{Err:n,_int:t,_tlv:r}=at,o=typeof e=="string"?hr(e):e;Nt(o);const{v:s,l:c}=r.decode(48,o);if(c.length)throw new n("invalid signature: left bytes after parsing");const{v:f,l:i}=r.decode(2,s),{v:d,l:a}=r.decode(2,i);if(a.length)throw new n("invalid signature: left bytes after parsing");return{r:t.decode(f),s:t.decode(d)}},hexFromSig(e){const{_tlv:n,_int:t}=at,r=n.encode(2,t.encode(e.r)),o=n.encode(2,t.encode(e.s)),s=r+o;return n.encode(48,s)}},lt=BigInt(0),W=BigInt(1);BigInt(2);const me=BigInt(3);BigInt(4);function gr(e){const n=ur(e),{Fp:t}=n,r=kt(n.n,n.nBitLength),o=n.toBytes||((p,u,m)=>{const v=u.toAffine();return Bt(Uint8Array.from([4]),t.toBytes(v.x),t.toBytes(v.y))}),s=n.fromBytes||(p=>{const u=p.subarray(1),m=t.fromBytes(u.subarray(0,t.BYTES)),v=t.fromBytes(u.subarray(t.BYTES,2*t.BYTES));return{x:m,y:v}});function c(p){const{a:u,b:m}=n,v=t.sqr(p),w=t.mul(v,p);return t.add(t.add(w,t.mul(p,u)),m)}if(!t.eql(t.sqr(n.Gy),c(n.Gx)))throw new Error("bad generator point: equation left != right");function f(p){return zt(p,W,n.n)}function i(p){const{allowedPrivateKeyLengths:u,nByteLength:m,wrapPrivateKey:v,n:w}=n;if(u&&typeof p!="bigint"){if(yt(p)&&(p=mt(p)),typeof p!="string"||!u.includes(p.length))throw new Error("invalid private key");p=p.padStart(m*2,"0")}let O;try{O=typeof p=="bigint"?p:pt(j("private key",p,m))}catch{throw new Error("invalid private key, expected hex or "+m+" bytes, got "+typeof p)}return v&&(O=M(O,w)),rt("private key",O,W,w),O}function d(p){if(!(p instanceof g))throw new Error("ProjectivePoint expected")}const a=Ot((p,u)=>{const{px:m,py:v,pz:w}=p;if(t.eql(w,t.ONE))return{x:m,y:v};const O=p.is0();u==null&&(u=O?t.ONE:t.inv(w));const q=t.mul(m,u),U=t.mul(v,u),H=t.mul(w,u);if(O)return{x:t.ZERO,y:t.ZERO};if(!t.eql(H,t.ONE))throw new Error("invZ was invalid");return{x:q,y:U}}),b=Ot(p=>{if(p.is0()){if(n.allowInfinityPoint&&!t.is0(p.py))return;throw new Error("bad point: ZERO")}const{x:u,y:m}=p.toAffine();if(!t.isValid(u)||!t.isValid(m))throw new Error("bad point: x or y not FE");const v=t.sqr(m),w=c(u);if(!t.eql(v,w))throw new Error("bad point: equation left != right");if(!p.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class g{constructor(u,m,v){if(this.px=u,this.py=m,this.pz=v,u==null||!t.isValid(u))throw new Error("x required");if(m==null||!t.isValid(m))throw new Error("y required");if(v==null||!t.isValid(v))throw new Error("z required");Object.freeze(this)}static fromAffine(u){const{x:m,y:v}=u||{};if(!u||!t.isValid(m)||!t.isValid(v))throw new Error("invalid affine point");if(u instanceof g)throw new Error("projective point not allowed");const w=O=>t.eql(O,t.ZERO);return w(m)&&w(v)?g.ZERO:new g(m,v,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(u){const m=t.invertBatch(u.map(v=>v.pz));return u.map((v,w)=>v.toAffine(m[w])).map(g.fromAffine)}static fromHex(u){const m=g.fromAffine(s(j("pointHex",u)));return m.assertValidity(),m}static fromPrivateKey(u){return g.BASE.multiply(i(u))}static msm(u,m){return Ce(g,r,u,m)}_setWindowSize(u){I.setWindowSize(this,u)}assertValidity(){b(this)}hasEvenY(){const{y:u}=this.toAffine();if(t.isOdd)return!t.isOdd(u);throw new Error("Field doesn't support isOdd")}equals(u){d(u);const{px:m,py:v,pz:w}=this,{px:O,py:q,pz:U}=u,H=t.eql(t.mul(m,U),t.mul(O,w)),L=t.eql(t.mul(v,U),t.mul(q,w));return H&&L}negate(){return new g(this.px,t.neg(this.py),this.pz)}double(){const{a:u,b:m}=n,v=t.mul(m,me),{px:w,py:O,pz:q}=this;let U=t.ZERO,H=t.ZERO,L=t.ZERO,A=t.mul(w,w),Y=t.mul(O,O),k=t.mul(q,q),Z=t.mul(w,O);return Z=t.add(Z,Z),L=t.mul(w,q),L=t.add(L,L),U=t.mul(u,L),H=t.mul(v,k),H=t.add(U,H),U=t.sub(Y,H),H=t.add(Y,H),H=t.mul(U,H),U=t.mul(Z,U),L=t.mul(v,L),k=t.mul(u,k),Z=t.sub(A,k),Z=t.mul(u,Z),Z=t.add(Z,L),L=t.add(A,A),A=t.add(L,A),A=t.add(A,k),A=t.mul(A,Z),H=t.add(H,A),k=t.mul(O,q),k=t.add(k,k),A=t.mul(k,Z),U=t.sub(U,A),L=t.mul(k,Y),L=t.add(L,L),L=t.add(L,L),new g(U,H,L)}add(u){d(u);const{px:m,py:v,pz:w}=this,{px:O,py:q,pz:U}=u;let H=t.ZERO,L=t.ZERO,A=t.ZERO;const Y=n.a,k=t.mul(n.b,me);let Z=t.mul(m,O),K=t.mul(v,q),y=t.mul(w,U),S=t.add(m,v),h=t.add(O,q);S=t.mul(S,h),h=t.add(Z,K),S=t.sub(S,h),h=t.add(m,w);let l=t.add(O,U);return h=t.mul(h,l),l=t.add(Z,y),h=t.sub(h,l),l=t.add(v,w),H=t.add(q,U),l=t.mul(l,H),H=t.add(K,y),l=t.sub(l,H),A=t.mul(Y,h),H=t.mul(k,y),A=t.add(H,A),H=t.sub(K,A),A=t.add(K,A),L=t.mul(H,A),K=t.add(Z,Z),K=t.add(K,Z),y=t.mul(Y,y),h=t.mul(k,h),K=t.add(K,y),y=t.sub(Z,y),y=t.mul(Y,y),h=t.add(h,y),Z=t.mul(K,h),L=t.add(L,Z),Z=t.mul(l,h),H=t.mul(S,H),H=t.sub(H,Z),Z=t.mul(S,K),A=t.mul(l,A),A=t.add(A,Z),new g(H,L,A)}subtract(u){return this.add(u.negate())}is0(){return this.equals(g.ZERO)}wNAF(u){return I.wNAFCached(this,u,g.normalizeZ)}multiplyUnsafe(u){const{endo:m,n:v}=n;rt("scalar",u,lt,v);const w=g.ZERO;if(u===lt)return w;if(this.is0()||u===W)return this;if(!m||I.hasPrecomputes(this))return I.wNAFCachedUnsafe(this,u,g.normalizeZ);let{k1neg:O,k1:q,k2neg:U,k2:H}=m.splitScalar(u),L=w,A=w,Y=this;for(;q>lt||H>lt;)q&W&&(L=L.add(Y)),H&W&&(A=A.add(Y)),Y=Y.double(),q>>=W,H>>=W;return O&&(L=L.negate()),U&&(A=A.negate()),A=new g(t.mul(A.px,m.beta),A.py,A.pz),L.add(A)}multiply(u){const{endo:m,n:v}=n;rt("scalar",u,W,v);let w,O;if(m){const{k1neg:q,k1:U,k2neg:H,k2:L}=m.splitScalar(u);let{p:A,f:Y}=this.wNAF(U),{p:k,f:Z}=this.wNAF(L);A=I.constTimeNegate(q,A),k=I.constTimeNegate(H,k),k=new g(t.mul(k.px,m.beta),k.py,k.pz),w=A.add(k),O=Y.add(Z)}else{const{p:q,f:U}=this.wNAF(u);w=q,O=U}return g.normalizeZ([w,O])[0]}multiplyAndAddUnsafe(u,m,v){const w=g.BASE,O=(U,H)=>H===lt||H===W||!U.equals(w)?U.multiplyUnsafe(H):U.multiply(H),q=O(this,m).add(O(u,v));return q.is0()?void 0:q}toAffine(u){return a(this,u)}isTorsionFree(){const{h:u,isTorsionFree:m}=n;if(u===W)return!0;if(m)return m(g,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:u,clearCofactor:m}=n;return u===W?this:m?m(g,this):this.multiplyUnsafe(n.h)}toRawBytes(u=!0){return ut("isCompressed",u),this.assertValidity(),o(g,this,u)}toHex(u=!0){return ut("isCompressed",u),mt(this.toRawBytes(u))}}g.BASE=new g(n.Gx,n.Gy,t.ONE),g.ZERO=new g(t.ZERO,t.ONE,t.ZERO);const E=n.nBitLength,I=Re(g,n.endo?Math.ceil(E/2):E);return{CURVE:n,ProjectivePoint:g,normPrivateKeyToScalar:i,weierstrassEquation:c,isWithinCurveOrder:f}}function br(e){const n=ne(e);return Ht(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function xr(e){const n=br(e),{Fp:t,n:r}=n,o=t.BYTES+1,s=2*t.BYTES+1;function c(y){return M(y,r)}function f(y){return Wt(y,r)}const{ProjectivePoint:i,normPrivateKeyToScalar:d,weierstrassEquation:a,isWithinCurveOrder:b}=gr({...n,toBytes(y,S,h){const l=S.toAffine(),x=t.toBytes(l.x),B=Bt;return ut("isCompressed",h),h?B(Uint8Array.from([S.hasEvenY()?2:3]),x):B(Uint8Array.from([4]),x,t.toBytes(l.y))},fromBytes(y){const S=y.length,h=y[0],l=y.subarray(1);if(S===o&&(h===2||h===3)){const x=pt(l);if(!zt(x,W,t.ORDER))throw new Error("Point is not on curve");const B=a(x);let N;try{N=t.sqrt(B)}catch(z){const T=z instanceof Error?": "+z.message:"";throw new Error("Point is not on curve"+T)}const _=(N&W)===W;return(h&1)===1!==_&&(N=t.neg(N)),{x,y:N}}else if(S===s&&h===4){const x=t.fromBytes(l.subarray(0,t.BYTES)),B=t.fromBytes(l.subarray(t.BYTES,2*t.BYTES));return{x,y:B}}else{const x=o,B=s;throw new Error("invalid Point, expected length of "+x+", or uncompressed "+B+", got "+S)}}}),g=y=>mt(It(y,n.nByteLength));function E(y){const S=r>>W;return y>S}function I(y){return E(y)?c(-y):y}const p=(y,S,h)=>pt(y.slice(S,h));class u{constructor(S,h,l){this.r=S,this.s=h,this.recovery=l,this.assertValidity()}static fromCompact(S){const h=n.nByteLength;return S=j("compactSignature",S,h*2),new u(p(S,0,h),p(S,h,2*h))}static fromDER(S){const{r:h,s:l}=at.toSig(j("DER",S));return new u(h,l)}assertValidity(){rt("r",this.r,W,r),rt("s",this.s,W,r)}addRecoveryBit(S){return new u(this.r,this.s,S)}recoverPublicKey(S){const{r:h,s:l,recovery:x}=this,B=U(j("msgHash",S));if(x==null||![0,1,2,3].includes(x))throw new Error("recovery id invalid");const N=x===2||x===3?h+n.n:h;if(N>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const _=(x&1)===0?"02":"03",C=i.fromHex(_+g(N)),z=f(N),T=c(-B*z),V=c(l*z),F=i.BASE.multiplyAndAddUnsafe(C,T,V);if(!F)throw new Error("point at infinify");return F.assertValidity(),F}hasHighS(){return E(this.s)}normalizeS(){return this.hasHighS()?new u(this.r,c(-this.s),this.recovery):this}toDERRawBytes(){return vt(this.toDERHex())}toDERHex(){return at.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return vt(this.toCompactHex())}toCompactHex(){return g(this.r)+g(this.s)}}const m={isValidPrivateKey(y){try{return d(y),!0}catch{return!1}},normPrivateKeyToScalar:d,randomPrivateKey:()=>{const y=Ue(n.n);return Kn(n.randomBytes(y),n.n)},precompute(y=8,S=i.BASE){return S._setWindowSize(y),S.multiply(BigInt(3)),S}};function v(y,S=!0){return i.fromPrivateKey(y).toRawBytes(S)}function w(y){const S=yt(y),h=typeof y=="string",l=(S||h)&&y.length;return S?l===o||l===s:h?l===2*o||l===2*s:y instanceof i}function O(y,S,h=!0){if(w(y))throw new Error("first arg must be private key");if(!w(S))throw new Error("second arg must be public key");return i.fromHex(S).multiply(d(y)).toRawBytes(h)}const q=n.bits2int||function(y){if(y.length>8192)throw new Error("input is too large");const S=pt(y),h=y.length*8-n.nBitLength;return h>0?S>>BigInt(h):S},U=n.bits2int_modN||function(y){return c(q(y))},H=ee(n.nBitLength);function L(y){return rt("num < 2^"+n.nBitLength,y,lt,H),It(y,n.nByteLength)}function A(y,S,h=Y){if(["recovered","canonical"].some(X=>X in h))throw new Error("sign() legacy options not supported");const{hash:l,randomBytes:x}=n;let{lowS:B,prehash:N,extraEntropy:_}=h;B==null&&(B=!0),y=j("msgHash",y),ye(h),N&&(y=j("prehashed msgHash",l(y)));const C=U(y),z=d(S),T=[L(z),L(C)];if(_!=null&&_!==!1){const X=_===!0?x(t.BYTES):_;T.push(j("extraEntropy",X))}const V=Bt(...T),F=C;function $(X){const Q=q(X);if(!b(Q))return;const J=f(Q),et=i.BASE.multiply(Q).toAffine(),tt=c(et.x);if(tt===lt)return;const st=c(J*c(F+tt*z));if(st===lt)return;let dt=(et.x===tt?0:2)|Number(et.y&W),ct=st;return B&&E(st)&&(ct=I(st),dt^=1),new u(tt,ct,dt)}return{seed:V,k2sig:$}}const Y={lowS:n.lowS,prehash:!1},k={lowS:n.lowS,prehash:!1};function Z(y,S,h=Y){const{seed:l,k2sig:x}=A(y,S,h),B=n;return Oe(B.hash.outputLen,B.nByteLength,B.hmac)(l,x)}i.BASE._setWindowSize(8);function K(y,S,h,l=k){var dt;const x=y;S=j("msgHash",S),h=j("publicKey",h);const{lowS:B,prehash:N,format:_}=l;if(ye(l),"strict"in l)throw new Error("options.strict was renamed to lowS");if(_!==void 0&&_!=="compact"&&_!=="der")throw new Error("format must be compact or der");const C=typeof x=="string"||yt(x),z=!C&&!_&&typeof x=="object"&&x!==null&&typeof x.r=="bigint"&&typeof x.s=="bigint";if(!C&&!z)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let T,V;try{if(z&&(T=new u(x.r,x.s)),C){try{_!=="compact"&&(T=u.fromDER(x))}catch(ct){if(!(ct instanceof at.Err))throw ct}!T&&_!=="der"&&(T=u.fromCompact(x))}V=i.fromHex(h)}catch{return!1}if(!T||B&&T.hasHighS())return!1;N&&(S=n.hash(S));const{r:F,s:$}=T,X=U(S),Q=f($),J=c(X*Q),et=c(F*Q),tt=(dt=i.BASE.multiplyAndAddUnsafe(V,J,et))==null?void 0:dt.toAffine();return tt?c(tt.x)===F:!1}return{CURVE:n,getPublicKey:v,getSharedSecret:O,sign:Z,verify:K,ProjectivePoint:i,Signature:u,utils:m}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function pr(e){return{hash:e,hmac:(n,...t)=>ze(e,n,Qe(...t)),randomBytes:ve}}function yr(e,n){const t=r=>xr({...e,...pr(r)});return{...t(n),create:t}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ke=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Be=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),mr=BigInt(1),Pt=BigInt(2),Ee=(e,n)=>(e+n/Pt)/n;function Br(e){const n=ke,t=BigInt(3),r=BigInt(6),o=BigInt(11),s=BigInt(22),c=BigInt(23),f=BigInt(44),i=BigInt(88),d=e*e*e%n,a=d*d*e%n,b=D(a,t,n)*a%n,g=D(b,t,n)*a%n,E=D(g,Pt,n)*d%n,I=D(E,o,n)*E%n,p=D(I,s,n)*I%n,u=D(p,f,n)*p%n,m=D(u,i,n)*u%n,v=D(m,f,n)*p%n,w=D(v,t,n)*a%n,O=D(w,c,n)*I%n,q=D(O,r,n)*d%n,U=D(q,Pt,n);if(!Qt.eql(Qt.sqr(U),e))throw new Error("Cannot find square root");return U}const Qt=kt(ke,void 0,void 0,{sqrt:Br}),Sr=yr({a:BigInt(0),b:BigInt(7),Fp:Qt,n:Be,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:e=>{const n=Be,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-mr*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=t,c=BigInt("0x100000000000000000000000000000000"),f=Ee(s*e,n),i=Ee(-r*e,n);let d=M(e-f*t-i*o,n),a=M(-f*r-i*s,n);const b=d>c,g=a>c;if(b&&(d=n-d),g&&(a=n-a),d>c||a>c)throw new Error("splitScalar: Endomorphism failed, k="+e);return{k1neg:b,k1:d,k2neg:g,k2:a}}}},lr);BigInt(0);export{lr as a,Er as e,Sr as s};
