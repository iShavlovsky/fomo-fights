const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/@solflare-wallet-CjY9iZv-.js","assets/@babel-D6-XlEtG.js","assets/bs58-DGbdKtE6.js","assets/base-x-B1yCoRlk.js"])))=>i.map(i=>d[i]);
var js=Object.defineProperty;var zs=(i,e,t)=>e in i?js(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t;var zt=(i,e,t)=>zs(i,typeof e!="symbol"?e+"":e,t);import{r as B,R as on}from"./react-B5jr9g3P.js";import{S as gt,a as ks,c as xs,b as _s,d as Os}from"./@solana-mobile-R23FBDkj.js";import{S as an,a as cn,b as Wt,c as Cs,D as Rs,r as Bs}from"./@wallet-standard-Cum7St90.js";import{r as vs,b as P}from"./buffer-DWQSt5K4.js";import{_ as Jn}from"./@particle-network-CoTp-LGl.js";import{E as Us}from"./eventemitter3-BxrP2y_4.js";import{s as Ps,a as Nn,e as un}from"./@noble-B1pyrsxt.js";import{B as An}from"./bn.js-BkBmvZSs.js";import{g as Ws}from"./@babel-D6-XlEtG.js";import{r as Ys}from"./safe-buffer-PaMJ6TrP.js";import{l as kt}from"./borsh-BtPkMup1.js";import{c as dt,s as T,i as ln,t as dn,l as J,u as nt,a as S,n as f,b as D,d as j,o as R,e as Ae,r as Xn,f as he,g as Qs,h as E}from"./superstruct-DeH2Te0P.js";import{R as Ks}from"./jayson-BezVhxNc.js";import{C as Fs,W as qs}from"./rpc-websockets-uDdV8Q-g.js";var xt,Tn;function Gs(){if(Tn)return xt;Tn=1;var i=Ys().Buffer;function e(t){if(t.length>=255)throw new TypeError("Alphabet too long");for(var n=new Uint8Array(256),s=0;s<n.length;s++)n[s]=255;for(var r=0;r<t.length;r++){var o=t.charAt(r),u=o.charCodeAt(0);if(n[u]!==255)throw new TypeError(o+" is ambiguous");n[u]=r}var d=t.length,y=t.charAt(0),m=Math.log(d)/Math.log(256),I=Math.log(256)/Math.log(d);function z(p){if((Array.isArray(p)||p instanceof Uint8Array)&&(p=i.from(p)),!i.isBuffer(p))throw new TypeError("Expected Buffer");if(p.length===0)return"";for(var b=0,O=0,k=0,v=p.length;k!==v&&p[k]===0;)k++,b++;for(var q=(v-k)*I+1>>>0,ie=new Uint8Array(q);k!==v;){for(var K=p[k],fe=0,ge=q-1;(K!==0||fe<O)&&ge!==-1;ge--,fe++)K+=256*ie[ge]>>>0,ie[ge]=K%d>>>0,K=K/d>>>0;if(K!==0)throw new Error("Non-zero carry");O=fe,k++}for(var oe=q-O;oe!==q&&ie[oe]===0;)oe++;for(var Se=y.repeat(b);oe<q;++oe)Se+=t.charAt(ie[oe]);return Se}function L(p){if(typeof p!="string")throw new TypeError("Expected String");if(p.length===0)return i.alloc(0);for(var b=0,O=0,k=0;p[b]===y;)O++,b++;for(var v=(p.length-b)*m+1>>>0,q=new Uint8Array(v);b<p.length;){var ie=p.charCodeAt(b);if(ie>255)return;var K=n[ie];if(K===255)return;for(var fe=0,ge=v-1;(K!==0||fe<k)&&ge!==-1;ge--,fe++)K+=d*q[ge]>>>0,q[ge]=K%256>>>0,K=K/256>>>0;if(K!==0)throw new Error("Non-zero carry");k=fe,b++}for(var oe=v-k;oe!==v&&q[oe]===0;)oe++;var Se=i.allocUnsafe(O+(v-oe));Se.fill(0,0,O);for(var ze=O;oe!==v;)Se[ze++]=q[oe++];return Se}function A(p){var b=L(p);if(b)return b;throw new Error("Non-base"+d+" character")}return{encode:z,decodeUnsafe:L,decode:A}}return xt=e,xt}var _t,Ln;function Hs(){if(Ln)return _t;Ln=1;var i=Gs(),e="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";return _t=i(e),_t}var Vs=Hs();const le=Ws(Vs);var g={},En;function Zs(){if(En)return g;En=1,Object.defineProperty(g,"__esModule",{value:!0}),g.s16=g.s8=g.nu64be=g.u48be=g.u40be=g.u32be=g.u24be=g.u16be=g.nu64=g.u48=g.u40=g.u32=g.u24=g.u16=g.u8=g.offset=g.greedy=g.Constant=g.UTF8=g.CString=g.Blob=g.Boolean=g.BitField=g.BitStructure=g.VariantLayout=g.Union=g.UnionLayoutDiscriminator=g.UnionDiscriminator=g.Structure=g.Sequence=g.DoubleBE=g.Double=g.FloatBE=g.Float=g.NearInt64BE=g.NearInt64=g.NearUInt64BE=g.NearUInt64=g.IntBE=g.Int=g.UIntBE=g.UInt=g.OffsetLayout=g.GreedyCount=g.ExternalLayout=g.bindConstructorLayout=g.nameWithProperty=g.Layout=g.uint8ArrayToBuffer=g.checkUint8Array=void 0,g.constant=g.utf8=g.cstr=g.blob=g.unionLayoutDiscriminator=g.union=g.seq=g.bits=g.struct=g.f64be=g.f64=g.f32be=g.f32=g.ns64be=g.s48be=g.s40be=g.s32be=g.s24be=g.s16be=g.ns64=g.s48=g.s40=g.s32=g.s24=void 0;const i=vs();function e(w){if(!(w instanceof Uint8Array))throw new TypeError("b must be a Uint8Array")}g.checkUint8Array=e;function t(w){return e(w),i.Buffer.from(w.buffer,w.byteOffset,w.length)}g.uint8ArrayToBuffer=t;let n=class{constructor(a,c){if(!Number.isInteger(a))throw new TypeError("span must be an integer");this.span=a,this.property=c}makeDestinationObject(){return{}}getSpan(a,c){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(a){const c=Object.create(this.constructor.prototype);return Object.assign(c,this),c.property=a,c}fromArray(a){}};g.Layout=n;function s(w,a){return a.property?w+"["+a.property+"]":w}g.nameWithProperty=s;function r(w,a){if(typeof w!="function")throw new TypeError("Class must be constructor");if(Object.prototype.hasOwnProperty.call(w,"layout_"))throw new Error("Class is already bound to a layout");if(!(a&&a instanceof n))throw new TypeError("layout must be a Layout");if(Object.prototype.hasOwnProperty.call(a,"boundConstructor_"))throw new Error("layout is already bound to a constructor");w.layout_=a,a.boundConstructor_=w,a.makeDestinationObject=()=>new w,Object.defineProperty(w.prototype,"encode",{value(c,h){return a.encode(this,c,h)},writable:!0}),Object.defineProperty(w,"decode",{value(c,h){return a.decode(c,h)},writable:!0})}g.bindConstructorLayout=r;class o extends n{isCount(){throw new Error("ExternalLayout is abstract")}}g.ExternalLayout=o;class u extends o{constructor(a=1,c){if(!Number.isInteger(a)||0>=a)throw new TypeError("elementSpan must be a (positive) integer");super(-1,c),this.elementSpan=a}isCount(){return!0}decode(a,c=0){e(a);const h=a.length-c;return Math.floor(h/this.elementSpan)}encode(a,c,h){return 0}}g.GreedyCount=u;class d extends o{constructor(a,c=0,h){if(!(a instanceof n))throw new TypeError("layout must be a Layout");if(!Number.isInteger(c))throw new TypeError("offset must be integer or undefined");super(a.span,h||a.property),this.layout=a,this.offset=c}isCount(){return this.layout instanceof y||this.layout instanceof m}decode(a,c=0){return this.layout.decode(a,c+this.offset)}encode(a,c,h=0){return this.layout.encode(a,c,h+this.offset)}}g.OffsetLayout=d;class y extends n{constructor(a,c){if(super(a,c),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(a,c=0){return t(a).readUIntLE(c,this.span)}encode(a,c,h=0){return t(c).writeUIntLE(a,h,this.span),this.span}}g.UInt=y;class m extends n{constructor(a,c){if(super(a,c),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(a,c=0){return t(a).readUIntBE(c,this.span)}encode(a,c,h=0){return t(c).writeUIntBE(a,h,this.span),this.span}}g.UIntBE=m;class I extends n{constructor(a,c){if(super(a,c),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(a,c=0){return t(a).readIntLE(c,this.span)}encode(a,c,h=0){return t(c).writeIntLE(a,h,this.span),this.span}}g.Int=I;class z extends n{constructor(a,c){if(super(a,c),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(a,c=0){return t(a).readIntBE(c,this.span)}encode(a,c,h=0){return t(c).writeIntBE(a,h,this.span),this.span}}g.IntBE=z;const L=Math.pow(2,32);function A(w){const a=Math.floor(w/L),c=w-a*L;return{hi32:a,lo32:c}}function p(w,a){return w*L+a}class b extends n{constructor(a){super(8,a)}decode(a,c=0){const h=t(a),M=h.readUInt32LE(c),N=h.readUInt32LE(c+4);return p(N,M)}encode(a,c,h=0){const M=A(a),N=t(c);return N.writeUInt32LE(M.lo32,h),N.writeUInt32LE(M.hi32,h+4),8}}g.NearUInt64=b;class O extends n{constructor(a){super(8,a)}decode(a,c=0){const h=t(a),M=h.readUInt32BE(c),N=h.readUInt32BE(c+4);return p(M,N)}encode(a,c,h=0){const M=A(a),N=t(c);return N.writeUInt32BE(M.hi32,h),N.writeUInt32BE(M.lo32,h+4),8}}g.NearUInt64BE=O;class k extends n{constructor(a){super(8,a)}decode(a,c=0){const h=t(a),M=h.readUInt32LE(c),N=h.readInt32LE(c+4);return p(N,M)}encode(a,c,h=0){const M=A(a),N=t(c);return N.writeUInt32LE(M.lo32,h),N.writeInt32LE(M.hi32,h+4),8}}g.NearInt64=k;class v extends n{constructor(a){super(8,a)}decode(a,c=0){const h=t(a),M=h.readInt32BE(c),N=h.readUInt32BE(c+4);return p(M,N)}encode(a,c,h=0){const M=A(a),N=t(c);return N.writeInt32BE(M.hi32,h),N.writeUInt32BE(M.lo32,h+4),8}}g.NearInt64BE=v;class q extends n{constructor(a){super(4,a)}decode(a,c=0){return t(a).readFloatLE(c)}encode(a,c,h=0){return t(c).writeFloatLE(a,h),4}}g.Float=q;class ie extends n{constructor(a){super(4,a)}decode(a,c=0){return t(a).readFloatBE(c)}encode(a,c,h=0){return t(c).writeFloatBE(a,h),4}}g.FloatBE=ie;class K extends n{constructor(a){super(8,a)}decode(a,c=0){return t(a).readDoubleLE(c)}encode(a,c,h=0){return t(c).writeDoubleLE(a,h),8}}g.Double=K;class fe extends n{constructor(a){super(8,a)}decode(a,c=0){return t(a).readDoubleBE(c)}encode(a,c,h=0){return t(c).writeDoubleBE(a,h),8}}g.DoubleBE=fe;class ge extends n{constructor(a,c,h){if(!(a instanceof n))throw new TypeError("elementLayout must be a Layout");if(!(c instanceof o&&c.isCount()||Number.isInteger(c)&&0<=c))throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");let M=-1;!(c instanceof o)&&0<a.span&&(M=c*a.span),super(M,h),this.elementLayout=a,this.count=c}getSpan(a,c=0){if(0<=this.span)return this.span;let h=0,M=this.count;if(M instanceof o&&(M=M.decode(a,c)),0<this.elementLayout.span)h=M*this.elementLayout.span;else{let N=0;for(;N<M;)h+=this.elementLayout.getSpan(a,c+h),++N}return h}decode(a,c=0){const h=[];let M=0,N=this.count;for(N instanceof o&&(N=N.decode(a,c));M<N;)h.push(this.elementLayout.decode(a,c)),c+=this.elementLayout.getSpan(a,c),M+=1;return h}encode(a,c,h=0){const M=this.elementLayout,N=a.reduce((G,se)=>G+M.encode(se,c,h+G),0);return this.count instanceof o&&this.count.encode(a.length,c,h),N}}g.Sequence=ge;class oe extends n{constructor(a,c,h){if(!(Array.isArray(a)&&a.reduce((N,G)=>N&&G instanceof n,!0)))throw new TypeError("fields must be array of Layout instances");typeof c=="boolean"&&h===void 0&&(h=c,c=void 0);for(const N of a)if(0>N.span&&N.property===void 0)throw new Error("fields cannot contain unnamed variable-length layout");let M=-1;try{M=a.reduce((N,G)=>N+G.getSpan(),0)}catch{}super(M,c),this.fields=a,this.decodePrefixes=!!h}getSpan(a,c=0){if(0<=this.span)return this.span;let h=0;try{h=this.fields.reduce((M,N)=>{const G=N.getSpan(a,c);return c+=G,M+G},0)}catch{throw new RangeError("indeterminate span")}return h}decode(a,c=0){e(a);const h=this.makeDestinationObject();for(const M of this.fields)if(M.property!==void 0&&(h[M.property]=M.decode(a,c)),c+=M.getSpan(a,c),this.decodePrefixes&&a.length===c)break;return h}encode(a,c,h=0){const M=h;let N=0,G=0;for(const se of this.fields){let xe=se.span;if(G=0<xe?xe:0,se.property!==void 0){const bn=a[se.property];bn!==void 0&&(G=se.encode(bn,c,h),0>xe&&(xe=se.getSpan(c,h)))}N=h,h+=xe}return N+G-M}fromArray(a){const c=this.makeDestinationObject();for(const h of this.fields)h.property!==void 0&&0<a.length&&(c[h.property]=a.shift());return c}layoutFor(a){if(typeof a!="string")throw new TypeError("property must be string");for(const c of this.fields)if(c.property===a)return c}offsetOf(a){if(typeof a!="string")throw new TypeError("property must be string");let c=0;for(const h of this.fields){if(h.property===a)return c;0>h.span?c=-1:0<=c&&(c+=h.span)}}}g.Structure=oe;class Se{constructor(a){this.property=a}decode(a,c){throw new Error("UnionDiscriminator is abstract")}encode(a,c,h){throw new Error("UnionDiscriminator is abstract")}}g.UnionDiscriminator=Se;class ze extends Se{constructor(a,c){if(!(a instanceof o&&a.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(c||a.property||"variant"),this.layout=a}decode(a,c){return this.layout.decode(a,c)}encode(a,c,h){return this.layout.encode(a,c,h)}}g.UnionLayoutDiscriminator=ze;class rt extends n{constructor(a,c,h){let M;if(a instanceof y||a instanceof m)M=new ze(new d(a));else if(a instanceof o&&a.isCount())M=new ze(a);else if(a instanceof Se)M=a;else throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");if(c===void 0&&(c=null),!(c===null||c instanceof n))throw new TypeError("defaultLayout must be null or a Layout");if(c!==null){if(0>c.span)throw new Error("defaultLayout must have constant span");c.property===void 0&&(c=c.replicate("content"))}let N=-1;c&&(N=c.span,0<=N&&(a instanceof y||a instanceof m)&&(N+=M.layout.span)),super(N,h),this.discriminator=M,this.usesPrefixDiscriminator=a instanceof y||a instanceof m,this.defaultLayout=c,this.registry={};let G=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(se){return G(se)},this.configGetSourceVariant=function(se){G=se.bind(this)}}getSpan(a,c=0){if(0<=this.span)return this.span;const h=this.getVariant(a,c);if(!h)throw new Error("unable to determine span for unrecognized variant");return h.getSpan(a,c)}defaultGetSourceVariant(a){if(Object.prototype.hasOwnProperty.call(a,this.discriminator.property)){if(this.defaultLayout&&this.defaultLayout.property&&Object.prototype.hasOwnProperty.call(a,this.defaultLayout.property))return;const c=this.registry[a[this.discriminator.property]];if(c&&(!c.layout||c.property&&Object.prototype.hasOwnProperty.call(a,c.property)))return c}else for(const c in this.registry){const h=this.registry[c];if(h.property&&Object.prototype.hasOwnProperty.call(a,h.property))return h}throw new Error("unable to infer src variant")}decode(a,c=0){let h;const M=this.discriminator,N=M.decode(a,c),G=this.registry[N];if(G===void 0){const se=this.defaultLayout;let xe=0;this.usesPrefixDiscriminator&&(xe=M.layout.span),h=this.makeDestinationObject(),h[M.property]=N,h[se.property]=se.decode(a,c+xe)}else h=G.decode(a,c);return h}encode(a,c,h=0){const M=this.getSourceVariant(a);if(M===void 0){const N=this.discriminator,G=this.defaultLayout;let se=0;return this.usesPrefixDiscriminator&&(se=N.layout.span),N.encode(a[N.property],c,h),se+G.encode(a[G.property],c,h+se)}return M.encode(a,c,h)}addVariant(a,c,h){const M=new ht(this,a,c,h);return this.registry[a]=M,M}getVariant(a,c=0){let h;return a instanceof Uint8Array?h=this.discriminator.decode(a,c):h=a,this.registry[h]}}g.Union=rt;class ht extends n{constructor(a,c,h,M){if(!(a instanceof rt))throw new TypeError("union must be a Union");if(!Number.isInteger(c)||0>c)throw new TypeError("variant must be a (non-negative) integer");if(typeof h=="string"&&M===void 0&&(M=h,h=null),h){if(!(h instanceof n))throw new TypeError("layout must be a Layout");if(a.defaultLayout!==null&&0<=h.span&&h.span>a.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if(typeof M!="string")throw new TypeError("variant must have a String property")}let N=a.span;0>a.span&&(N=h?h.span:0,0<=N&&a.usesPrefixDiscriminator&&(N+=a.discriminator.layout.span)),super(N,M),this.union=a,this.variant=c,this.layout=h||null}getSpan(a,c=0){if(0<=this.span)return this.span;let h=0;this.union.usesPrefixDiscriminator&&(h=this.union.discriminator.layout.span);let M=0;return this.layout&&(M=this.layout.getSpan(a,c+h)),h+M}decode(a,c=0){const h=this.makeDestinationObject();if(this!==this.union.getVariant(a,c))throw new Error("variant mismatch");let M=0;return this.union.usesPrefixDiscriminator&&(M=this.union.discriminator.layout.span),this.layout?h[this.property]=this.layout.decode(a,c+M):this.property?h[this.property]=!0:this.union.usesPrefixDiscriminator&&(h[this.union.discriminator.property]=this.variant),h}encode(a,c,h=0){let M=0;if(this.union.usesPrefixDiscriminator&&(M=this.union.discriminator.layout.span),this.layout&&!Object.prototype.hasOwnProperty.call(a,this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,c,h);let N=M;if(this.layout&&(this.layout.encode(a[this.property],c,h+M),N+=this.layout.getSpan(c,h+M),0<=this.union.span&&N>this.union.span))throw new Error("encoded variant overruns containing union");return N}fromArray(a){if(this.layout)return this.layout.fromArray(a)}}g.VariantLayout=ht;function ke(w){return 0>w&&(w+=4294967296),w}class Y extends n{constructor(a,c,h){if(!(a instanceof y||a instanceof m))throw new TypeError("word must be a UInt or UIntBE layout");if(typeof c=="string"&&h===void 0&&(h=c,c=!1),4<a.span)throw new RangeError("word cannot exceed 32 bits");super(a.span,h),this.word=a,this.msb=!!c,this.fields=[];let M=0;this._packedSetValue=function(N){return M=ke(N),this},this._packedGetValue=function(){return M}}decode(a,c=0){const h=this.makeDestinationObject(),M=this.word.decode(a,c);this._packedSetValue(M);for(const N of this.fields)N.property!==void 0&&(h[N.property]=N.decode(a));return h}encode(a,c,h=0){const M=this.word.decode(c,h);this._packedSetValue(M);for(const N of this.fields)if(N.property!==void 0){const G=a[N.property];G!==void 0&&N.encode(G)}return this.word.encode(this._packedGetValue(),c,h)}addField(a,c){const h=new V(this,a,c);return this.fields.push(h),h}addBoolean(a){const c=new ee(this,a);return this.fields.push(c),c}fieldFor(a){if(typeof a!="string")throw new TypeError("property must be string");for(const c of this.fields)if(c.property===a)return c}}g.BitStructure=Y;class V{constructor(a,c,h){if(!(a instanceof Y))throw new TypeError("container must be a BitStructure");if(!Number.isInteger(c)||0>=c)throw new TypeError("bits must be positive integer");const M=8*a.span,N=a.fields.reduce((G,se)=>G+se.bits,0);if(c+N>M)throw new Error("bits too long for span remainder ("+(M-N)+" of "+M+" remain)");this.container=a,this.bits=c,this.valueMask=(1<<c)-1,c===32&&(this.valueMask=4294967295),this.start=N,this.container.msb&&(this.start=M-N-c),this.wordMask=ke(this.valueMask<<this.start),this.property=h}decode(a,c){const h=this.container._packedGetValue();return ke(h&this.wordMask)>>>this.start}encode(a){if(typeof a!="number"||!Number.isInteger(a)||a!==ke(a&this.valueMask))throw new TypeError(s("BitField.encode",this)+" value must be integer not exceeding "+this.valueMask);const c=this.container._packedGetValue(),h=ke(a<<this.start);this.container._packedSetValue(ke(c&~this.wordMask)|h)}}g.BitField=V;class ee extends V{constructor(a,c){super(a,1,c)}decode(a,c){return!!super.decode(a,c)}encode(a){typeof a=="boolean"&&(a=+a),super.encode(a)}}g.Boolean=ee;class we extends n{constructor(a,c){if(!(a instanceof o&&a.isCount()||Number.isInteger(a)&&0<=a))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let h=-1;a instanceof o||(h=a),super(h,c),this.length=a}getSpan(a,c){let h=this.span;return 0>h&&(h=this.length.decode(a,c)),h}decode(a,c=0){let h=this.span;return 0>h&&(h=this.length.decode(a,c)),t(a).slice(c,c+h)}encode(a,c,h){let M=this.length;if(this.length instanceof o&&(M=a.length),!(a instanceof Uint8Array&&M===a.length))throw new TypeError(s("Blob.encode",this)+" requires (length "+M+") Uint8Array as src");if(h+M>c.length)throw new RangeError("encoding overruns Uint8Array");const N=t(a);return t(c).write(N.toString("hex"),h,M,"hex"),this.length instanceof o&&this.length.encode(M,c,h),M}}g.Blob=we;class Te extends n{constructor(a){super(-1,a)}getSpan(a,c=0){e(a);let h=c;for(;h<a.length&&a[h]!==0;)h+=1;return 1+h-c}decode(a,c=0){const h=this.getSpan(a,c);return t(a).slice(c,c+h-1).toString("utf-8")}encode(a,c,h=0){typeof a!="string"&&(a=String(a));const M=i.Buffer.from(a,"utf8"),N=M.length;if(h+N>c.length)throw new RangeError("encoding overruns Buffer");const G=t(c);return M.copy(G,h),G[h+N]=0,N+1}}g.CString=Te;class Qe extends n{constructor(a,c){if(typeof a=="string"&&c===void 0&&(c=a,a=void 0),a===void 0)a=-1;else if(!Number.isInteger(a))throw new TypeError("maxSpan must be an integer");super(-1,c),this.maxSpan=a}getSpan(a,c=0){return e(a),a.length-c}decode(a,c=0){const h=this.getSpan(a,c);if(0<=this.maxSpan&&this.maxSpan<h)throw new RangeError("text length exceeds maxSpan");return t(a).slice(c,c+h).toString("utf-8")}encode(a,c,h=0){typeof a!="string"&&(a=String(a));const M=i.Buffer.from(a,"utf8"),N=M.length;if(0<=this.maxSpan&&this.maxSpan<N)throw new RangeError("text length exceeds maxSpan");if(h+N>c.length)throw new RangeError("encoding overruns Buffer");return M.copy(t(c),h),N}}g.UTF8=Qe;class In extends n{constructor(a,c){super(0,c),this.value=a}decode(a,c){return this.value}encode(a,c,h){return 0}}return g.Constant=In,g.greedy=(w,a)=>new u(w,a),g.offset=(w,a,c)=>new d(w,a,c),g.u8=w=>new y(1,w),g.u16=w=>new y(2,w),g.u24=w=>new y(3,w),g.u32=w=>new y(4,w),g.u40=w=>new y(5,w),g.u48=w=>new y(6,w),g.nu64=w=>new b(w),g.u16be=w=>new m(2,w),g.u24be=w=>new m(3,w),g.u32be=w=>new m(4,w),g.u40be=w=>new m(5,w),g.u48be=w=>new m(6,w),g.nu64be=w=>new O(w),g.s8=w=>new I(1,w),g.s16=w=>new I(2,w),g.s24=w=>new I(3,w),g.s32=w=>new I(4,w),g.s40=w=>new I(5,w),g.s48=w=>new I(6,w),g.ns64=w=>new k(w),g.s16be=w=>new z(2,w),g.s24be=w=>new z(3,w),g.s32be=w=>new z(4,w),g.s40be=w=>new z(5,w),g.s48be=w=>new z(6,w),g.ns64be=w=>new v(w),g.f32=w=>new q(w),g.f32be=w=>new ie(w),g.f64=w=>new K(w),g.f64be=w=>new fe(w),g.struct=(w,a,c)=>new oe(w,a,c),g.bits=(w,a,c)=>new Y(w,a,c),g.seq=(w,a,c)=>new ge(w,a,c),g.union=(w,a,c)=>new rt(w,a,c),g.unionLayoutDiscriminator=(w,a)=>new ze(w,a),g.blob=(w,a)=>new we(w,a),g.cstr=w=>new Te(w),g.utf8=(w,a)=>new Qe(w,a),g.constant=(w,a)=>new In(w,a),g}var l=Zs(),$s=8078e3,Js=8078001,Xs=8078004,er=8078005,tr=8078006,nr=8078011;function es(i){return Array.isArray(i)?"%5B"+i.map(es).join("%2C%20")+"%5D":typeof i=="bigint"?`${i}n`:encodeURIComponent(String(i!=null&&Object.getPrototypeOf(i)===null?{...i}:i))}function sr([i,e]){return`${i}=${es(e)}`}function rr(i){const e=Object.entries(i).map(sr).join("&");return btoa(e)}function ir(i,e={}){{let t=`Solana error #${i}; Decode this error by running \`npx @solana/errors decode -- ${i}`;return Object.keys(e).length&&(t+=` '${rr(e)}'`),`${t}\``}}var Ve=class extends Error{constructor(...[e,t]){let n,s;if(t){const{cause:o,...u}=t;o&&(s={cause:o}),Object.keys(u).length>0&&(n=u)}const r=ir(e,n);super(r,s);zt(this,"cause",this.cause);zt(this,"context");this.context={__code:e,...n},this.name="SolanaError"}};function or(i,e){return"fixedSize"in e?e.fixedSize:e.getSizeFromValue(i)}function ar(i){return Object.freeze({...i,encode:e=>{const t=new Uint8Array(or(e,i));return i.write(e,t,0),t}})}function cr(i){return Object.freeze({...i,decode:(e,t=0)=>i.read(e,t)[0]})}function Ke(i){return"fixedSize"in i&&typeof i.fixedSize=="number"}function ur(i,e){if(Ke(i)!==Ke(e))throw new Ve(Xs);if(Ke(i)&&Ke(e)&&i.fixedSize!==e.fixedSize)throw new Ve(er,{decoderFixedSize:e.fixedSize,encoderFixedSize:i.fixedSize});if(!Ke(i)&&!Ke(e)&&i.maxSize!==e.maxSize)throw new Ve(tr,{decoderMaxSize:e.maxSize,encoderMaxSize:i.maxSize});return{...e,...i,decode:e.decode,encode:i.encode,read:e.read,write:i.write}}function lr(i,e,t=0){if(e.length-t<=0)throw new Ve($s,{codecDescription:i})}function dr(i,e,t,n=0){const s=t.length-n;if(s<e)throw new Ve(Js,{bytesLength:s,codecDescription:i,expected:e})}function hr(i,e,t,n){if(n<e||n>t)throw new Ve(nr,{codecDescription:i,max:t,min:e,value:n})}function ts(i){return(i==null?void 0:i.endian)!==1}function fr(i){return ar({fixedSize:i.size,write(e,t,n){i.range&&hr(i.name,i.range[0],i.range[1],e);const s=new ArrayBuffer(i.size);return i.set(new DataView(s),e,ts(i.config)),t.set(new Uint8Array(s),n),n+i.size}})}function gr(i){return cr({fixedSize:i.size,read(e,t=0){lr(i.name,e,t),dr(i.name,i.size,e,t);const n=new DataView(yr(e,t,i.size));return[i.get(n,ts(i.config)),t+i.size]}})}function yr(i,e,t){const n=i.byteOffset+(e??0),s=t??i.byteLength;return i.buffer.slice(n,n+s)}var wr=(i={})=>fr({config:i,name:"u64",range:[0n,BigInt("0xffffffffffffffff")],set:(e,t,n)=>e.setBigUint64(0,BigInt(t),n),size:8}),pr=(i={})=>gr({config:i,get:(e,t)=>e.getBigUint64(0,t),name:"u64",size:8}),Mr=(i={})=>ur(wr(i),pr(i));function Dn(i){try{return un.ExtendedPoint.fromHex(i),!0}catch{return!1}}const ns=(i,e)=>un.sign(i,e.slice(0,32)),mr=un.verify,Je=i=>P.Buffer.isBuffer(i)?i:i instanceof Uint8Array?P.Buffer.from(i.buffer,i.byteOffset,i.byteLength):P.Buffer.from(i);class Sr{constructor(e){Object.assign(this,e)}encode(){return P.Buffer.from(kt.serialize(yt,this))}static decode(e){return kt.deserialize(yt,this,e)}static decodeUnchecked(e){return kt.deserializeUnchecked(yt,this,e)}}const yt=new Map;var ss;const Ir=32,Re=32;function br(i){return i._bn!==void 0}let jn=1;class C extends Sr{constructor(e){if(super({}),this._bn=void 0,br(e))this._bn=e._bn;else{if(typeof e=="string"){const t=le.decode(e);if(t.length!=Re)throw new Error("Invalid public key input");this._bn=new An(t)}else this._bn=new An(e);if(this._bn.byteLength()>Re)throw new Error("Invalid public key input")}}static unique(){const e=new C(jn);return jn+=1,new C(e.toBuffer())}equals(e){return this._bn.eq(e._bn)}toBase58(){return le.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const e=this.toBuffer();return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}toBuffer(){const e=this._bn.toArrayLike(P.Buffer);if(e.length===Re)return e;const t=P.Buffer.alloc(32);return e.copy(t,32-e.length),t}get[Symbol.toStringTag](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(e,t,n){const s=P.Buffer.concat([e.toBuffer(),P.Buffer.from(t),n.toBuffer()]),r=Nn(s);return new C(r)}static createProgramAddressSync(e,t){let n=P.Buffer.alloc(0);e.forEach(function(r){if(r.length>Ir)throw new TypeError("Max seed length exceeded");n=P.Buffer.concat([n,Je(r)])}),n=P.Buffer.concat([n,t.toBuffer(),P.Buffer.from("ProgramDerivedAddress")]);const s=Nn(n);if(Dn(s))throw new Error("Invalid seeds, address must fall off the curve");return new C(s)}static async createProgramAddress(e,t){return this.createProgramAddressSync(e,t)}static findProgramAddressSync(e,t){let n=255,s;for(;n!=0;){try{const r=e.concat(P.Buffer.from([n]));s=this.createProgramAddressSync(r,t)}catch(r){if(r instanceof TypeError)throw r;n--;continue}return[s,n]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(e,t){return this.findProgramAddressSync(e,t)}static isOnCurve(e){const t=new C(e);return Dn(t.toBytes())}}ss=C;C.default=new ss("11111111111111111111111111111111");yt.set(C,{kind:"struct",fields:[["_bn","u256"]]});new C("BPFLoader1111111111111111111111111111111111");const Ze=1232,hn=127,Mt=64;class rs extends Error{constructor(e){super(`Signature ${e} has expired: block height exceeded.`),this.signature=void 0,this.signature=e}}Object.defineProperty(rs.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class is extends Error{constructor(e,t){super(`Transaction was not confirmed in ${t.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${e} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=e}}Object.defineProperty(is.prototype,"name",{value:"TransactionExpiredTimeoutError"});class ot extends Error{constructor(e){super(`Signature ${e} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=e}}Object.defineProperty(ot.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});class mt{constructor(e,t){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=e,this.accountKeysFromLookups=t}keySegments(){const e=[this.staticAccountKeys];return this.accountKeysFromLookups&&(e.push(this.accountKeysFromLookups.writable),e.push(this.accountKeysFromLookups.readonly)),e}get(e){for(const t of this.keySegments()){if(e<t.length)return t[e];e-=t.length}}get length(){return this.keySegments().flat().length}compileInstructions(e){if(this.length>256)throw new Error("Account index overflow encountered during compilation");const n=new Map;this.keySegments().flat().forEach((r,o)=>{n.set(r.toBase58(),o)});const s=r=>{const o=n.get(r.toBase58());if(o===void 0)throw new Error("Encountered an unknown instruction account key during compilation");return o};return e.map(r=>({programIdIndex:s(r.programId),accountKeyIndexes:r.keys.map(o=>s(o.pubkey)),data:r.data}))}}const W=(i="publicKey")=>l.blob(32,i),Nr=(i="signature")=>l.blob(64,i),Ge=(i="string")=>{const e=l.struct([l.u32("length"),l.u32("lengthPadding"),l.blob(l.offset(l.u32(),-8),"chars")],i),t=e.decode.bind(e),n=e.encode.bind(e),s=e;return s.decode=(r,o)=>t(r,o).chars.toString(),s.encode=(r,o,u)=>{const d={chars:P.Buffer.from(r,"utf8")};return n(d,o,u)},s.alloc=r=>l.u32().span+l.u32().span+P.Buffer.from(r,"utf8").length,s},Ar=(i="authorized")=>l.struct([W("staker"),W("withdrawer")],i),Tr=(i="lockup")=>l.struct([l.ns64("unixTimestamp"),l.ns64("epoch"),W("custodian")],i),Lr=(i="voteInit")=>l.struct([W("nodePubkey"),W("authorizedVoter"),W("authorizedWithdrawer"),l.u8("commission")],i),Er=(i="voteAuthorizeWithSeedArgs")=>l.struct([l.u32("voteAuthorizationType"),W("currentAuthorityDerivedKeyOwnerPubkey"),Ge("currentAuthorityDerivedKeySeed"),W("newAuthorized")],i);function pe(i){let e=0,t=0;for(;;){let n=i.shift();if(e|=(n&127)<<t*7,t+=1,(n&128)===0)break}return e}function Me(i,e){let t=e;for(;;){let n=t&127;if(t>>=7,t==0){i.push(n);break}else n|=128,i.push(n)}}function $(i,e){if(!i)throw new Error(e||"Assertion failed")}class Tt{constructor(e,t){this.payer=void 0,this.keyMetaMap=void 0,this.payer=e,this.keyMetaMap=t}static compile(e,t){const n=new Map,s=o=>{const u=o.toBase58();let d=n.get(u);return d===void 0&&(d={isSigner:!1,isWritable:!1,isInvoked:!1},n.set(u,d)),d},r=s(t);r.isSigner=!0,r.isWritable=!0;for(const o of e){s(o.programId).isInvoked=!0;for(const u of o.keys){const d=s(u.pubkey);d.isSigner||(d.isSigner=u.isSigner),d.isWritable||(d.isWritable=u.isWritable)}}return new Tt(t,n)}getMessageComponents(){const e=[...this.keyMetaMap.entries()];$(e.length<=256,"Max static account keys length exceeded");const t=e.filter(([,d])=>d.isSigner&&d.isWritable),n=e.filter(([,d])=>d.isSigner&&!d.isWritable),s=e.filter(([,d])=>!d.isSigner&&d.isWritable),r=e.filter(([,d])=>!d.isSigner&&!d.isWritable),o={numRequiredSignatures:t.length+n.length,numReadonlySignedAccounts:n.length,numReadonlyUnsignedAccounts:r.length};{$(t.length>0,"Expected at least one writable signer key");const[d]=t[0];$(d===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const u=[...t.map(([d])=>new C(d)),...n.map(([d])=>new C(d)),...s.map(([d])=>new C(d)),...r.map(([d])=>new C(d))];return[o,u]}extractTableLookup(e){const[t,n]=this.drainKeysFoundInLookupTable(e.state.addresses,o=>!o.isSigner&&!o.isInvoked&&o.isWritable),[s,r]=this.drainKeysFoundInLookupTable(e.state.addresses,o=>!o.isSigner&&!o.isInvoked&&!o.isWritable);if(!(t.length===0&&s.length===0))return[{accountKey:e.key,writableIndexes:t,readonlyIndexes:s},{writable:n,readonly:r}]}drainKeysFoundInLookupTable(e,t){const n=new Array,s=new Array;for(const[r,o]of this.keyMetaMap.entries())if(t(o)){const u=new C(r),d=e.findIndex(y=>y.equals(u));d>=0&&($(d<256,"Max lookup table index exceeded"),n.push(d),s.push(u),this.keyMetaMap.delete(r))}return[n,s]}}const os="Reached end of buffer unexpectedly";function Le(i){if(i.length===0)throw new Error(os);return i.shift()}function me(i,...e){const[t]=e;if(e.length===2?t+(e[1]??0)>i.length:t>=i.length)throw new Error(os);return i.splice(...e)}class je{constructor(e){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=e.header,this.accountKeys=e.accountKeys.map(t=>new C(t)),this.recentBlockhash=e.recentBlockhash,this.instructions=e.instructions,this.instructions.forEach(t=>this.indexToProgramIds.set(t.programIdIndex,this.accountKeys[t.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:le.decode(e.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new mt(this.staticAccountKeys)}static compile(e){const t=Tt.compile(e.instructions,e.payerKey),[n,s]=t.getMessageComponents(),o=new mt(s).compileInstructions(e.instructions).map(u=>({programIdIndex:u.programIdIndex,accounts:u.accountKeyIndexes,data:le.encode(u.data)}));return new je({header:n,accountKeys:s,recentBlockhash:e.recentBlockhash,instructions:o})}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures;if(e>=this.header.numRequiredSignatures){const n=e-t,r=this.accountKeys.length-t-this.header.numReadonlyUnsignedAccounts;return n<r}else{const n=t-this.header.numReadonlySignedAccounts;return e<n}}isProgramId(e){return this.indexToProgramIds.has(e)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((e,t)=>!this.isProgramId(t))}serialize(){const e=this.accountKeys.length;let t=[];Me(t,e);const n=this.instructions.map(I=>{const{accounts:z,programIdIndex:L}=I,A=Array.from(le.decode(I.data));let p=[];Me(p,z.length);let b=[];return Me(b,A.length),{programIdIndex:L,keyIndicesCount:P.Buffer.from(p),keyIndices:z,dataLength:P.Buffer.from(b),data:A}});let s=[];Me(s,n.length);let r=P.Buffer.alloc(Ze);P.Buffer.from(s).copy(r);let o=s.length;n.forEach(I=>{const L=l.struct([l.u8("programIdIndex"),l.blob(I.keyIndicesCount.length,"keyIndicesCount"),l.seq(l.u8("keyIndex"),I.keyIndices.length,"keyIndices"),l.blob(I.dataLength.length,"dataLength"),l.seq(l.u8("userdatum"),I.data.length,"data")]).encode(I,r,o);o+=L}),r=r.slice(0,o);const u=l.struct([l.blob(1,"numRequiredSignatures"),l.blob(1,"numReadonlySignedAccounts"),l.blob(1,"numReadonlyUnsignedAccounts"),l.blob(t.length,"keyCount"),l.seq(W("key"),e,"keys"),W("recentBlockhash")]),d={numRequiredSignatures:P.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:P.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:P.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:P.Buffer.from(t),keys:this.accountKeys.map(I=>Je(I.toBytes())),recentBlockhash:le.decode(this.recentBlockhash)};let y=P.Buffer.alloc(2048);const m=u.encode(d,y);return r.copy(y,m),y.slice(0,m+r.length)}static from(e){let t=[...e];const n=Le(t);if(n!==(n&hn))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const s=Le(t),r=Le(t),o=pe(t);let u=[];for(let z=0;z<o;z++){const L=me(t,0,Re);u.push(new C(P.Buffer.from(L)))}const d=me(t,0,Re),y=pe(t);let m=[];for(let z=0;z<y;z++){const L=Le(t),A=pe(t),p=me(t,0,A),b=pe(t),O=me(t,0,b),k=le.encode(P.Buffer.from(O));m.push({programIdIndex:L,accounts:p,data:k})}const I={header:{numRequiredSignatures:n,numReadonlySignedAccounts:s,numReadonlyUnsignedAccounts:r},recentBlockhash:le.encode(P.Buffer.from(d)),accountKeys:u,instructions:m};return new je(I)}}class ut{constructor(e){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=e.header,this.staticAccountKeys=e.staticAccountKeys,this.recentBlockhash=e.recentBlockhash,this.compiledInstructions=e.compiledInstructions,this.addressTableLookups=e.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let e=0;for(const t of this.addressTableLookups)e+=t.readonlyIndexes.length+t.writableIndexes.length;return e}getAccountKeys(e){let t;if(e&&"accountKeysFromLookups"in e&&e.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=e.accountKeysFromLookups.writable.length+e.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");t=e.accountKeysFromLookups}else if(e&&"addressLookupTableAccounts"in e&&e.addressLookupTableAccounts)t=this.resolveAddressTableLookups(e.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new mt(this.staticAccountKeys,t)}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures,n=this.staticAccountKeys.length;if(e>=n){const s=e-n,r=this.addressTableLookups.reduce((o,u)=>o+u.writableIndexes.length,0);return s<r}else if(e>=this.header.numRequiredSignatures){const s=e-t,o=n-t-this.header.numReadonlyUnsignedAccounts;return s<o}else{const s=t-this.header.numReadonlySignedAccounts;return e<s}}resolveAddressTableLookups(e){const t={writable:[],readonly:[]};for(const n of this.addressTableLookups){const s=e.find(r=>r.key.equals(n.accountKey));if(!s)throw new Error(`Failed to find address lookup table account for table key ${n.accountKey.toBase58()}`);for(const r of n.writableIndexes)if(r<s.state.addresses.length)t.writable.push(s.state.addresses[r]);else throw new Error(`Failed to find address for index ${r} in address lookup table ${n.accountKey.toBase58()}`);for(const r of n.readonlyIndexes)if(r<s.state.addresses.length)t.readonly.push(s.state.addresses[r]);else throw new Error(`Failed to find address for index ${r} in address lookup table ${n.accountKey.toBase58()}`)}return t}static compile(e){const t=Tt.compile(e.instructions,e.payerKey),n=new Array,s={writable:new Array,readonly:new Array},r=e.addressLookupTableAccounts||[];for(const m of r){const I=t.extractTableLookup(m);if(I!==void 0){const[z,{writable:L,readonly:A}]=I;n.push(z),s.writable.push(...L),s.readonly.push(...A)}}const[o,u]=t.getMessageComponents(),y=new mt(u,s).compileInstructions(e.instructions);return new ut({header:o,staticAccountKeys:u,recentBlockhash:e.recentBlockhash,compiledInstructions:y,addressTableLookups:n})}serialize(){const e=Array();Me(e,this.staticAccountKeys.length);const t=this.serializeInstructions(),n=Array();Me(n,this.compiledInstructions.length);const s=this.serializeAddressTableLookups(),r=Array();Me(r,this.addressTableLookups.length);const o=l.struct([l.u8("prefix"),l.struct([l.u8("numRequiredSignatures"),l.u8("numReadonlySignedAccounts"),l.u8("numReadonlyUnsignedAccounts")],"header"),l.blob(e.length,"staticAccountKeysLength"),l.seq(W(),this.staticAccountKeys.length,"staticAccountKeys"),W("recentBlockhash"),l.blob(n.length,"instructionsLength"),l.blob(t.length,"serializedInstructions"),l.blob(r.length,"addressTableLookupsLength"),l.blob(s.length,"serializedAddressTableLookups")]),u=new Uint8Array(Ze),y=o.encode({prefix:128,header:this.header,staticAccountKeysLength:new Uint8Array(e),staticAccountKeys:this.staticAccountKeys.map(m=>m.toBytes()),recentBlockhash:le.decode(this.recentBlockhash),instructionsLength:new Uint8Array(n),serializedInstructions:t,addressTableLookupsLength:new Uint8Array(r),serializedAddressTableLookups:s},u);return u.slice(0,y)}serializeInstructions(){let e=0;const t=new Uint8Array(Ze);for(const n of this.compiledInstructions){const s=Array();Me(s,n.accountKeyIndexes.length);const r=Array();Me(r,n.data.length);const o=l.struct([l.u8("programIdIndex"),l.blob(s.length,"encodedAccountKeyIndexesLength"),l.seq(l.u8(),n.accountKeyIndexes.length,"accountKeyIndexes"),l.blob(r.length,"encodedDataLength"),l.blob(n.data.length,"data")]);e+=o.encode({programIdIndex:n.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(s),accountKeyIndexes:n.accountKeyIndexes,encodedDataLength:new Uint8Array(r),data:n.data},t,e)}return t.slice(0,e)}serializeAddressTableLookups(){let e=0;const t=new Uint8Array(Ze);for(const n of this.addressTableLookups){const s=Array();Me(s,n.writableIndexes.length);const r=Array();Me(r,n.readonlyIndexes.length);const o=l.struct([W("accountKey"),l.blob(s.length,"encodedWritableIndexesLength"),l.seq(l.u8(),n.writableIndexes.length,"writableIndexes"),l.blob(r.length,"encodedReadonlyIndexesLength"),l.seq(l.u8(),n.readonlyIndexes.length,"readonlyIndexes")]);e+=o.encode({accountKey:n.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(s),writableIndexes:n.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(r),readonlyIndexes:n.readonlyIndexes},t,e)}return t.slice(0,e)}static deserialize(e){let t=[...e];const n=Le(t),s=n&hn;$(n!==s,"Expected versioned message but received legacy message");const r=s;$(r===0,`Expected versioned message with version 0 but found version ${r}`);const o={numRequiredSignatures:Le(t),numReadonlySignedAccounts:Le(t),numReadonlyUnsignedAccounts:Le(t)},u=[],d=pe(t);for(let A=0;A<d;A++)u.push(new C(me(t,0,Re)));const y=le.encode(me(t,0,Re)),m=pe(t),I=[];for(let A=0;A<m;A++){const p=Le(t),b=pe(t),O=me(t,0,b),k=pe(t),v=new Uint8Array(me(t,0,k));I.push({programIdIndex:p,accountKeyIndexes:O,data:v})}const z=pe(t),L=[];for(let A=0;A<z;A++){const p=new C(me(t,0,Re)),b=pe(t),O=me(t,0,b),k=pe(t),v=me(t,0,k);L.push({accountKey:p,writableIndexes:O,readonlyIndexes:v})}return new ut({header:o,staticAccountKeys:u,recentBlockhash:y,compiledInstructions:I,addressTableLookups:L})}}const as={deserializeMessageVersion(i){const e=i[0],t=e&hn;return t===e?"legacy":t},deserialize:i=>{const e=as.deserializeMessageVersion(i);if(e==="legacy")return je.from(i);if(e===0)return ut.deserialize(i);throw new Error(`Transaction message version ${e} deserialization is not supported`)}};let _e=function(i){return i[i.BLOCKHEIGHT_EXCEEDED=0]="BLOCKHEIGHT_EXCEEDED",i[i.PROCESSED=1]="PROCESSED",i[i.TIMED_OUT=2]="TIMED_OUT",i[i.NONCE_INVALID=3]="NONCE_INVALID",i}({});const Dr=P.Buffer.alloc(Mt).fill(0);class zn{constructor(e){this.keys=void 0,this.programId=void 0,this.data=P.Buffer.alloc(0),this.programId=e.programId,this.keys=e.keys,e.data&&(this.data=e.data)}toJSON(){return{keys:this.keys.map(({pubkey:e,isSigner:t,isWritable:n})=>({pubkey:e.toJSON(),isSigner:t,isWritable:n})),programId:this.programId.toJSON(),data:[...this.data]}}}class Ne{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(e){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,!!e)if(e.feePayer&&(this.feePayer=e.feePayer),e.signatures&&(this.signatures=e.signatures),Object.prototype.hasOwnProperty.call(e,"nonceInfo")){const{minContextSlot:t,nonceInfo:n}=e;this.minNonceContextSlot=t,this.nonceInfo=n}else if(Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")){const{blockhash:t,lastValidBlockHeight:n}=e;this.recentBlockhash=t,this.lastValidBlockHeight=n}else{const{recentBlockhash:t,nonceInfo:n}=e;n&&(this.nonceInfo=n),this.recentBlockhash=t}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(e=>e.toJSON()),signers:this.signatures.map(({publicKey:e})=>e.toJSON())}}add(...e){if(e.length===0)throw new Error("No instructions");return e.forEach(t=>{"instructions"in t?this.instructions=this.instructions.concat(t.instructions):"data"in t&&"programId"in t&&"keys"in t?this.instructions.push(t):this.instructions.push(new zn(t))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let e,t;if(this.nonceInfo?(e=this.nonceInfo.nonce,this.instructions[0]!=this.nonceInfo.nonceInstruction?t=[this.nonceInfo.nonceInstruction,...this.instructions]:t=this.instructions):(e=this.recentBlockhash,t=this.instructions),!e)throw new Error("Transaction recentBlockhash required");t.length<1&&console.warn("No instructions provided");let n;if(this.feePayer)n=this.feePayer;else if(this.signatures.length>0&&this.signatures[0].publicKey)n=this.signatures[0].publicKey;else throw new Error("Transaction fee payer required");for(let p=0;p<t.length;p++)if(t[p].programId===void 0)throw new Error(`Transaction instruction index ${p} has undefined program id`);const s=[],r=[];t.forEach(p=>{p.keys.forEach(O=>{r.push({...O})});const b=p.programId.toString();s.includes(b)||s.push(b)}),s.forEach(p=>{r.push({pubkey:new C(p),isSigner:!1,isWritable:!1})});const o=[];r.forEach(p=>{const b=p.pubkey.toString(),O=o.findIndex(k=>k.pubkey.toString()===b);O>-1?(o[O].isWritable=o[O].isWritable||p.isWritable,o[O].isSigner=o[O].isSigner||p.isSigner):o.push(p)}),o.sort(function(p,b){if(p.isSigner!==b.isSigner)return p.isSigner?-1:1;if(p.isWritable!==b.isWritable)return p.isWritable?-1:1;const O={localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"};return p.pubkey.toBase58().localeCompare(b.pubkey.toBase58(),"en",O)});const u=o.findIndex(p=>p.pubkey.equals(n));if(u>-1){const[p]=o.splice(u,1);p.isSigner=!0,p.isWritable=!0,o.unshift(p)}else o.unshift({pubkey:n,isSigner:!0,isWritable:!0});for(const p of this.signatures){const b=o.findIndex(O=>O.pubkey.equals(p.publicKey));if(b>-1)o[b].isSigner||(o[b].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));else throw new Error(`unknown signer: ${p.publicKey.toString()}`)}let d=0,y=0,m=0;const I=[],z=[];o.forEach(({pubkey:p,isSigner:b,isWritable:O})=>{b?(I.push(p.toString()),d+=1,O||(y+=1)):(z.push(p.toString()),O||(m+=1))});const L=I.concat(z),A=t.map(p=>{const{data:b,programId:O}=p;return{programIdIndex:L.indexOf(O.toString()),accounts:p.keys.map(k=>L.indexOf(k.pubkey.toString())),data:le.encode(b)}});return A.forEach(p=>{$(p.programIdIndex>=0),p.accounts.forEach(b=>$(b>=0))}),new je({header:{numRequiredSignatures:d,numReadonlySignedAccounts:y,numReadonlyUnsignedAccounts:m},accountKeys:L,recentBlockhash:e,instructions:A})}_compile(){const e=this.compileMessage(),t=e.accountKeys.slice(0,e.header.numRequiredSignatures);return this.signatures.length===t.length&&this.signatures.every((s,r)=>t[r].equals(s.publicKey))||(this.signatures=t.map(n=>({signature:null,publicKey:n}))),e}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(e){return(await e.getFeeForMessage(this.compileMessage())).value}setSigners(...e){if(e.length===0)throw new Error("No signers");const t=new Set;this.signatures=e.filter(n=>{const s=n.toString();return t.has(s)?!1:(t.add(s),!0)}).map(n=>({signature:null,publicKey:n}))}sign(...e){if(e.length===0)throw new Error("No signers");const t=new Set,n=[];for(const r of e){const o=r.publicKey.toString();t.has(o)||(t.add(o),n.push(r))}this.signatures=n.map(r=>({signature:null,publicKey:r.publicKey}));const s=this._compile();this._partialSign(s,...n)}partialSign(...e){if(e.length===0)throw new Error("No signers");const t=new Set,n=[];for(const r of e){const o=r.publicKey.toString();t.has(o)||(t.add(o),n.push(r))}const s=this._compile();this._partialSign(s,...n)}_partialSign(e,...t){const n=e.serialize();t.forEach(s=>{const r=ns(n,s.secretKey);this._addSignature(s.publicKey,Je(r))})}addSignature(e,t){this._compile(),this._addSignature(e,t)}_addSignature(e,t){$(t.length===64);const n=this.signatures.findIndex(s=>e.equals(s.publicKey));if(n<0)throw new Error(`unknown signer: ${e.toString()}`);this.signatures[n].signature=P.Buffer.from(t)}verifySignatures(e=!0){return!this._getMessageSignednessErrors(this.serializeMessage(),e)}_getMessageSignednessErrors(e,t){const n={};for(const{signature:s,publicKey:r}of this.signatures)s===null?t&&(n.missing||(n.missing=[])).push(r):mr(s,e,r.toBytes())||(n.invalid||(n.invalid=[])).push(r);return n.invalid||n.missing?n:void 0}serialize(e){const{requireAllSignatures:t,verifySignatures:n}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},e),s=this.serializeMessage();if(n){const r=this._getMessageSignednessErrors(s,t);if(r){let o="Signature verification failed.";throw r.invalid&&(o+=`
Invalid signature for public key${r.invalid.length===1?"":"(s)"} [\`${r.invalid.map(u=>u.toBase58()).join("`, `")}\`].`),r.missing&&(o+=`
Missing signature for public key${r.missing.length===1?"":"(s)"} [\`${r.missing.map(u=>u.toBase58()).join("`, `")}\`].`),new Error(o)}}return this._serialize(s)}_serialize(e){const{signatures:t}=this,n=[];Me(n,t.length);const s=n.length+t.length*64+e.length,r=P.Buffer.alloc(s);return $(t.length<256),P.Buffer.from(n).copy(r,0),t.forEach(({signature:o},u)=>{o!==null&&($(o.length===64,"signature has invalid length"),P.Buffer.from(o).copy(r,n.length+u*64))}),e.copy(r,n.length+t.length*64),$(r.length<=Ze,`Transaction too large: ${r.length} > ${Ze}`),r}get keys(){return $(this.instructions.length===1),this.instructions[0].keys.map(e=>e.pubkey)}get programId(){return $(this.instructions.length===1),this.instructions[0].programId}get data(){return $(this.instructions.length===1),this.instructions[0].data}static from(e){let t=[...e];const n=pe(t);let s=[];for(let r=0;r<n;r++){const o=me(t,0,Mt);s.push(le.encode(P.Buffer.from(o)))}return Ne.populate(je.from(t),s)}static populate(e,t=[]){const n=new Ne;return n.recentBlockhash=e.recentBlockhash,e.header.numRequiredSignatures>0&&(n.feePayer=e.accountKeys[0]),t.forEach((s,r)=>{const o={signature:s==le.encode(Dr)?null:le.decode(s),publicKey:e.accountKeys[r]};n.signatures.push(o)}),e.instructions.forEach(s=>{const r=s.accounts.map(o=>{const u=e.accountKeys[o];return{pubkey:u,isSigner:n.signatures.some(d=>d.publicKey.toString()===u.toString())||e.isAccountSigner(o),isWritable:e.isAccountWritable(o)}});n.instructions.push(new zn({keys:r,programId:e.accountKeys[s.programIdIndex],data:le.decode(s.data)}))}),n._message=e,n._json=n.toJSON(),n}}class St{get version(){return this.message.version}constructor(e,t){if(this.signatures=void 0,this.message=void 0,t!==void 0)$(t.length===e.header.numRequiredSignatures,"Expected signatures length to be equal to the number of required signatures"),this.signatures=t;else{const n=[];for(let s=0;s<e.header.numRequiredSignatures;s++)n.push(new Uint8Array(Mt));this.signatures=n}this.message=e}serialize(){const e=this.message.serialize(),t=Array();Me(t,this.signatures.length);const n=l.struct([l.blob(t.length,"encodedSignaturesLength"),l.seq(Nr(),this.signatures.length,"signatures"),l.blob(e.length,"serializedMessage")]),s=new Uint8Array(2048),r=n.encode({encodedSignaturesLength:new Uint8Array(t),signatures:this.signatures,serializedMessage:e},s);return s.slice(0,r)}static deserialize(e){let t=[...e];const n=[],s=pe(t);for(let o=0;o<s;o++)n.push(new Uint8Array(me(t,0,Mt)));const r=as.deserialize(new Uint8Array(t));return new St(r,n)}sign(e){const t=this.message.serialize(),n=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures);for(const s of e){const r=n.findIndex(o=>o.equals(s.publicKey));$(r>=0,`Cannot sign with non signer key ${s.publicKey.toBase58()}`),this.signatures[r]=ns(t,s.secretKey)}}addSignature(e,t){$(t.byteLength===64,"Signature must be 64 bytes long");const s=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures).findIndex(r=>r.equals(e));$(s>=0,`Can not add signature; \`${e.toBase58()}\` is not required to sign this transaction`),this.signatures[s]=t}}const jr=160,zr=64,kr=jr/zr,xr=1e3/kr;new C("SysvarC1ock11111111111111111111111111111111");new C("SysvarEpochSchedu1e111111111111111111111111");new C("Sysvar1nstructions1111111111111111111111111");new C("SysvarRecentB1ockHashes11111111111111111111");new C("SysvarRent111111111111111111111111111111111");new C("SysvarRewards111111111111111111111111111111");new C("SysvarS1otHashes111111111111111111111111111");new C("SysvarS1otHistory11111111111111111111111111");new C("SysvarStakeHistory1111111111111111111111111");class kn extends Error{constructor({action:e,signature:t,transactionMessage:n,logs:s}){const r=s?`Logs: 
${JSON.stringify(s.slice(-10),null,2)}. `:"",o="\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.";let u;switch(e){case"send":u=`Transaction ${t} resulted in an error. 
${n}. `+r+o;break;case"simulate":u=`Simulation failed. 
Message: ${n}. 
`+r+o;break;default:u=`Unknown action '${(d=>d)(e)}'`}super(u),this.signature=void 0,this.transactionMessage=void 0,this.transactionLogs=void 0,this.signature=t,this.transactionMessage=n,this.transactionLogs=s||void 0}get transactionError(){return{message:this.transactionMessage,logs:Array.isArray(this.transactionLogs)?this.transactionLogs:void 0}}get logs(){const e=this.transactionLogs;if(!(e!=null&&typeof e=="object"&&"then"in e))return e}async getLogs(e){return Array.isArray(this.transactionLogs)||(this.transactionLogs=new Promise((t,n)=>{e.getTransaction(this.signature).then(s=>{if(s&&s.meta&&s.meta.logMessages){const r=s.meta.logMessages;this.transactionLogs=r,t(r)}else n(new Error("Log messages not found"))}).catch(n)})),await this.transactionLogs}}class _ extends Error{constructor({code:e,message:t,data:n},s){super(s!=null?`${s}: ${t}`:t),this.code=void 0,this.data=void 0,this.code=e,this.data=n,this.name="SolanaJSONRPCError"}}function Fe(i){return new Promise(e=>setTimeout(e,i))}const _r=l.nu64("lamportsPerSignature"),cs=l.struct([l.u32("version"),l.u32("state"),W("authorizedPubkey"),W("nonce"),l.struct([_r],"feeCalculator")]);cs.span;class fn{constructor(e){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=e.authorizedPubkey,this.nonce=e.nonce,this.feeCalculator=e.feeCalculator}static fromAccountData(e){const t=cs.decode(Je(e),0);return new fn({authorizedPubkey:new C(t.authorizedPubkey),nonce:new C(t.nonce).toString(),feeCalculator:t.feeCalculator})}}function Xe(i){const e=l.blob(8,i),t=e.decode.bind(e),n=e.encode.bind(e),s=e,r=Mr();return s.decode=(o,u)=>{const d=t(o,u);return r.decode(d)},s.encode=(o,u,d)=>{const y=r.encode(o);return n(y,u,d)},s}Object.freeze({Create:{index:0,layout:l.struct([l.u32("instruction"),l.ns64("lamports"),l.ns64("space"),W("programId")])},Assign:{index:1,layout:l.struct([l.u32("instruction"),W("programId")])},Transfer:{index:2,layout:l.struct([l.u32("instruction"),Xe("lamports")])},CreateWithSeed:{index:3,layout:l.struct([l.u32("instruction"),W("base"),Ge("seed"),l.ns64("lamports"),l.ns64("space"),W("programId")])},AdvanceNonceAccount:{index:4,layout:l.struct([l.u32("instruction")])},WithdrawNonceAccount:{index:5,layout:l.struct([l.u32("instruction"),l.ns64("lamports")])},InitializeNonceAccount:{index:6,layout:l.struct([l.u32("instruction"),W("authorized")])},AuthorizeNonceAccount:{index:7,layout:l.struct([l.u32("instruction"),W("authorized")])},Allocate:{index:8,layout:l.struct([l.u32("instruction"),l.ns64("space")])},AllocateWithSeed:{index:9,layout:l.struct([l.u32("instruction"),W("base"),Ge("seed"),l.ns64("space"),W("programId")])},AssignWithSeed:{index:10,layout:l.struct([l.u32("instruction"),W("base"),Ge("seed"),W("programId")])},TransferWithSeed:{index:11,layout:l.struct([l.u32("instruction"),Xe("lamports"),Ge("seed"),W("programId")])},UpgradeNonceAccount:{index:12,layout:l.struct([l.u32("instruction")])}});new C("11111111111111111111111111111111");new C("BPFLoader2111111111111111111111111111111111");function Or(i){return i&&i.__esModule&&Object.prototype.hasOwnProperty.call(i,"default")?i.default:i}var Ot,xn;function Cr(){if(xn)return Ot;xn=1;var i=Object.prototype.toString,e=Object.keys||function(n){var s=[];for(var r in n)s.push(r);return s};function t(n,s){var r,o,u,d,y,m,I;if(n===!0)return"true";if(n===!1)return"false";switch(typeof n){case"object":if(n===null)return null;if(n.toJSON&&typeof n.toJSON=="function")return t(n.toJSON(),s);if(I=i.call(n),I==="[object Array]"){for(u="[",o=n.length-1,r=0;r<o;r++)u+=t(n[r],!0)+",";return o>-1&&(u+=t(n[r],!0)),u+"]"}else if(I==="[object Object]"){for(d=e(n).sort(),o=d.length,u="",r=0;r<o;)y=d[r],m=t(n[y],!1),m!==void 0&&(u&&(u+=","),u+=JSON.stringify(y)+":"+m),r++;return"{"+u+"}"}else return JSON.stringify(n);case"function":case"undefined":return s?null:void 0;case"string":return JSON.stringify(n);default:return isFinite(n)?n:null}}return Ot=function(n){var s=t(n,!1);if(s!==void 0)return""+s},Ot}var Rr=Cr(),_n=Or(Rr);const it=32;function Ct(i){let e=0;for(;i>1;)i/=2,e++;return e}function Br(i){return i===0?1:(i--,i|=i>>1,i|=i>>2,i|=i>>4,i|=i>>8,i|=i>>16,i|=i>>32,i+1)}class vr{constructor(e,t,n,s,r){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=e,this.leaderScheduleSlotOffset=t,this.warmup=n,this.firstNormalEpoch=s,this.firstNormalSlot=r}getEpoch(e){return this.getEpochAndSlotIndex(e)[0]}getEpochAndSlotIndex(e){if(e<this.firstNormalSlot){const t=Ct(Br(e+it+1))-Ct(it)-1,n=this.getSlotsInEpoch(t),s=e-(n-it);return[t,s]}else{const t=e-this.firstNormalSlot,n=Math.floor(t/this.slotsPerEpoch),s=this.firstNormalEpoch+n,r=t%this.slotsPerEpoch;return[s,r]}}getFirstSlotInEpoch(e){return e<=this.firstNormalEpoch?(Math.pow(2,e)-1)*it:(e-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(e){return this.getFirstSlotInEpoch(e)+this.getSlotsInEpoch(e)-1}getSlotsInEpoch(e){return e<this.firstNormalEpoch?Math.pow(2,e+Ct(it)):this.slotsPerEpoch}}var Ur=globalThis.fetch;class Pr extends Fs{constructor(e,t,n){const s=r=>{const o=qs(r,{autoconnect:!0,max_reconnects:5,reconnect:!0,reconnect_interval:1e3,...t});return"socket"in o?this.underlyingSocket=o.socket:this.underlyingSocket=o,o};super(s,e,t,n),this.underlyingSocket=void 0}call(...e){var n;const t=(n=this.underlyingSocket)==null?void 0:n.readyState;return t===1?super.call(...e):Promise.reject(new Error("Tried to call a JSON-RPC method `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}notify(...e){var n;const t=(n=this.underlyingSocket)==null?void 0:n.readyState;return t===1?super.notify(...e):Promise.reject(new Error("Tried to send a JSON-RPC notification `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}}function Wr(i,e){let t;try{t=i.layout.decode(e)}catch(n){throw new Error("invalid instruction; "+n)}if(t.typeIndex!==i.index)throw new Error(`invalid account data; account type mismatch ${t.typeIndex} != ${i.index}`);return t}const On=56;class Cn{constructor(e){this.key=void 0,this.state=void 0,this.key=e.key,this.state=e.state}isActive(){const e=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===e}static deserialize(e){const t=Wr(Yr,e),n=e.length-On;$(n>=0,"lookup table is invalid"),$(n%32===0,"lookup table is invalid");const s=n/32,{addresses:r}=l.struct([l.seq(W(),s,"addresses")]).decode(e.slice(On));return{deactivationSlot:t.deactivationSlot,lastExtendedSlot:t.lastExtendedSlot,lastExtendedSlotStartIndex:t.lastExtendedStartIndex,authority:t.authority.length!==0?new C(t.authority[0]):void 0,addresses:r.map(o=>new C(o))}}}const Yr={index:1,layout:l.struct([l.u32("typeIndex"),Xe("deactivationSlot"),l.nu64("lastExtendedSlot"),l.u8("lastExtendedStartIndex"),l.u8(),l.seq(W(),l.offset(l.u8(),-1),"authority")])},Qr=/^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;function Kr(i){const e=i.match(Qr);if(e==null)throw TypeError(`Failed to validate endpoint URL \`${i}\``);const[t,n,s,r]=e,o=i.startsWith("https:")?"wss:":"ws:",u=s==null?null:parseInt(s.slice(1),10),d=u==null?"":`:${u+1}`;return`${o}//${n}${d}${r}`}const X=dt(ln(C),T(),i=>new C(i)),us=dn([T(),J("base64")]),gn=dt(ln(P.Buffer),us,i=>P.Buffer.from(i[0],"base64")),Fr=30*1e3;function qr(i){if(/^https?:/.test(i)===!1)throw new TypeError("Endpoint URL must start with `http:` or `https:`.");return i}function Z(i){let e,t;if(typeof i=="string")e=i;else if(i){const{commitment:n,...s}=i;e=n,t=s}return{commitment:e,config:t}}function Rn(i){return i.map(e=>"memcmp"in e?{...e,memcmp:{...e.memcmp,encoding:e.memcmp.encoding??"base58"}}:e)}function ls(i){return he([S({jsonrpc:J("2.0"),id:T(),result:i}),S({jsonrpc:J("2.0"),id:T(),error:S({code:nt(),message:T(),data:R(Qs())})})])}const Gr=ls(nt());function U(i){return dt(ls(i),Gr,e=>"error"in e?e:{...e,result:E(e.result,i)})}function ne(i){return U(S({context:S({slot:f()}),value:i}))}function Lt(i){return S({context:S({slot:f()}),value:i})}function Rt(i,e){return i===0?new ut({header:e.header,staticAccountKeys:e.accountKeys.map(t=>new C(t)),recentBlockhash:e.recentBlockhash,compiledInstructions:e.instructions.map(t=>({programIdIndex:t.programIdIndex,accountKeyIndexes:t.accounts,data:le.decode(t.data)})),addressTableLookups:e.addressTableLookups}):new je(e)}const Hr=S({foundation:f(),foundationTerm:f(),initial:f(),taper:f(),terminal:f()}),Vr=U(D(j(S({epoch:f(),effectiveSlot:f(),amount:f(),postBalance:f(),commission:R(j(f()))})))),Zr=D(S({slot:f(),prioritizationFee:f()})),$r=S({total:f(),validator:f(),foundation:f(),epoch:f()}),Jr=S({epoch:f(),slotIndex:f(),slotsInEpoch:f(),absoluteSlot:f(),blockHeight:R(f()),transactionCount:R(f())}),Xr=S({slotsPerEpoch:f(),leaderScheduleSlotOffset:f(),warmup:Ae(),firstNormalEpoch:f(),firstNormalSlot:f()}),ei=Xn(T(),D(f())),We=j(he([S({}),T()])),ti=S({err:We}),ni=J("receivedSignature"),si=S({"solana-core":T(),"feature-set":R(f())}),ri=S({program:T(),programId:X,parsed:nt()}),ii=S({programId:X,accounts:D(X),data:T()}),Bn=ne(S({err:j(he([S({}),T()])),logs:j(D(T())),accounts:R(j(D(j(S({executable:Ae(),owner:T(),lamports:f(),data:D(T()),rentEpoch:R(f())}))))),unitsConsumed:R(f()),returnData:R(j(S({programId:T(),data:dn([T(),J("base64")])}))),innerInstructions:R(j(D(S({index:f(),instructions:D(he([ri,ii]))}))))})),oi=ne(S({byIdentity:Xn(T(),D(f())),range:S({firstSlot:f(),lastSlot:f()})}));function ai(i,e,t,n,s,r){const o=t||Ur;let u;r!=null&&console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");let d;return n&&(d=async(m,I)=>{const z=await new Promise((L,A)=>{try{n(m,I,(p,b)=>L([p,b]))}catch(p){A(p)}});return await o(...z)}),new Ks(async(m,I)=>{const z={method:"POST",body:m,agent:u,headers:Object.assign({"Content-Type":"application/json"},e||{},ao)};try{let L=5,A,p=500;for(;d?A=await d(i,z):A=await o(i,z),!(A.status!==429||s===!0||(L-=1,L===0));)console.error(`Server responded with ${A.status} ${A.statusText}.  Retrying after ${p}ms delay...`),await Fe(p),p*=2;const b=await A.text();A.ok?I(null,b):I(new Error(`${A.status} ${A.statusText}: ${b}`))}catch(L){L instanceof Error&&I(L)}},{})}function ci(i){return(e,t)=>new Promise((n,s)=>{i.request(e,t,(r,o)=>{if(r){s(r);return}n(o)})})}function ui(i){return e=>new Promise((t,n)=>{e.length===0&&t([]);const s=e.map(r=>i.request(r.methodName,r.args));i.request(s,(r,o)=>{if(r){n(r);return}t(o)})})}const li=U(Hr),di=U($r),hi=U(Zr),fi=U(Jr),gi=U(Xr),yi=U(ei),wi=U(f()),pi=ne(S({total:f(),circulating:f(),nonCirculating:f(),nonCirculatingAccounts:D(X)})),Yt=S({amount:T(),uiAmount:j(f()),decimals:f(),uiAmountString:R(T())}),Mi=ne(D(S({address:X,amount:T(),uiAmount:j(f()),decimals:f(),uiAmountString:R(T())}))),mi=ne(D(S({pubkey:X,account:S({executable:Ae(),owner:X,lamports:f(),data:gn,rentEpoch:f()})}))),Qt=S({program:T(),parsed:nt(),space:f()}),Si=ne(D(S({pubkey:X,account:S({executable:Ae(),owner:X,lamports:f(),data:Qt,rentEpoch:f()})}))),Ii=ne(D(S({lamports:f(),address:X}))),lt=S({executable:Ae(),owner:X,lamports:f(),data:gn,rentEpoch:f()}),bi=S({pubkey:X,account:lt}),Ni=dt(he([ln(P.Buffer),Qt]),he([us,Qt]),i=>Array.isArray(i)?E(i,gn):i),Kt=S({executable:Ae(),owner:X,lamports:f(),data:Ni,rentEpoch:f()}),Ai=S({pubkey:X,account:Kt}),Ti=S({state:he([J("active"),J("inactive"),J("activating"),J("deactivating")]),active:f(),inactive:f()}),Li=U(D(S({signature:T(),slot:f(),err:We,memo:j(T()),blockTime:R(j(f()))}))),Ei=U(D(S({signature:T(),slot:f(),err:We,memo:j(T()),blockTime:R(j(f()))}))),Di=S({subscription:f(),result:Lt(lt)}),ji=S({pubkey:X,account:lt}),zi=S({subscription:f(),result:Lt(ji)}),ki=S({parent:f(),slot:f(),root:f()}),xi=S({subscription:f(),result:ki}),_i=he([S({type:he([J("firstShredReceived"),J("completed"),J("optimisticConfirmation"),J("root")]),slot:f(),timestamp:f()}),S({type:J("createdBank"),parent:f(),slot:f(),timestamp:f()}),S({type:J("frozen"),slot:f(),timestamp:f(),stats:S({numTransactionEntries:f(),numSuccessfulTransactions:f(),numFailedTransactions:f(),maxTransactionsPerEntry:f()})}),S({type:J("dead"),slot:f(),timestamp:f(),err:T()})]),Oi=S({subscription:f(),result:_i}),Ci=S({subscription:f(),result:Lt(he([ti,ni]))}),Ri=S({subscription:f(),result:f()}),Bi=S({pubkey:T(),gossip:j(T()),tpu:j(T()),rpc:j(T()),version:j(T())}),vn=S({votePubkey:T(),nodePubkey:T(),activatedStake:f(),epochVoteAccount:Ae(),epochCredits:D(dn([f(),f(),f()])),commission:f(),lastVote:f(),rootSlot:j(f())}),vi=U(S({current:D(vn),delinquent:D(vn)})),Ui=he([J("processed"),J("confirmed"),J("finalized")]),Pi=S({slot:f(),confirmations:j(f()),err:We,confirmationStatus:R(Ui)}),Wi=ne(D(j(Pi))),Yi=U(f()),ds=S({accountKey:X,writableIndexes:D(f()),readonlyIndexes:D(f())}),yn=S({signatures:D(T()),message:S({accountKeys:D(T()),header:S({numRequiredSignatures:f(),numReadonlySignedAccounts:f(),numReadonlyUnsignedAccounts:f()}),instructions:D(S({accounts:D(f()),data:T(),programIdIndex:f()})),recentBlockhash:T(),addressTableLookups:R(D(ds))})}),hs=S({pubkey:X,signer:Ae(),writable:Ae(),source:R(he([J("transaction"),J("lookupTable")]))}),fs=S({accountKeys:D(hs),signatures:D(T())}),gs=S({parsed:nt(),program:T(),programId:X}),ys=S({accounts:D(X),data:T(),programId:X}),Qi=he([ys,gs]),Ki=he([S({parsed:nt(),program:T(),programId:T()}),S({accounts:D(T()),data:T(),programId:T()})]),ws=dt(Qi,Ki,i=>"accounts"in i?E(i,ys):E(i,gs)),ps=S({signatures:D(T()),message:S({accountKeys:D(hs),instructions:D(ws),recentBlockhash:T(),addressTableLookups:R(j(D(ds)))})}),It=S({accountIndex:f(),mint:T(),owner:R(T()),programId:R(T()),uiTokenAmount:Yt}),Ms=S({writable:D(X),readonly:D(X)}),Et=S({err:We,fee:f(),innerInstructions:R(j(D(S({index:f(),instructions:D(S({accounts:D(f()),data:T(),programIdIndex:f()}))})))),preBalances:D(f()),postBalances:D(f()),logMessages:R(j(D(T()))),preTokenBalances:R(j(D(It))),postTokenBalances:R(j(D(It))),loadedAddresses:R(Ms),computeUnitsConsumed:R(f())}),wn=S({err:We,fee:f(),innerInstructions:R(j(D(S({index:f(),instructions:D(ws)})))),preBalances:D(f()),postBalances:D(f()),logMessages:R(j(D(T()))),preTokenBalances:R(j(D(It))),postTokenBalances:R(j(D(It))),loadedAddresses:R(Ms),computeUnitsConsumed:R(f())}),st=he([J(0),J("legacy")]),Ye=S({pubkey:T(),lamports:f(),postBalance:j(f()),rewardType:j(T()),commission:R(j(f()))}),Fi=U(j(S({blockhash:T(),previousBlockhash:T(),parentSlot:f(),transactions:D(S({transaction:yn,meta:j(Et),version:R(st)})),rewards:R(D(Ye)),blockTime:j(f()),blockHeight:j(f())}))),qi=U(j(S({blockhash:T(),previousBlockhash:T(),parentSlot:f(),rewards:R(D(Ye)),blockTime:j(f()),blockHeight:j(f())}))),Gi=U(j(S({blockhash:T(),previousBlockhash:T(),parentSlot:f(),transactions:D(S({transaction:fs,meta:j(Et),version:R(st)})),rewards:R(D(Ye)),blockTime:j(f()),blockHeight:j(f())}))),Hi=U(j(S({blockhash:T(),previousBlockhash:T(),parentSlot:f(),transactions:D(S({transaction:ps,meta:j(wn),version:R(st)})),rewards:R(D(Ye)),blockTime:j(f()),blockHeight:j(f())}))),Vi=U(j(S({blockhash:T(),previousBlockhash:T(),parentSlot:f(),transactions:D(S({transaction:fs,meta:j(wn),version:R(st)})),rewards:R(D(Ye)),blockTime:j(f()),blockHeight:j(f())}))),Zi=U(j(S({blockhash:T(),previousBlockhash:T(),parentSlot:f(),rewards:R(D(Ye)),blockTime:j(f()),blockHeight:j(f())}))),$i=U(j(S({blockhash:T(),previousBlockhash:T(),parentSlot:f(),transactions:D(S({transaction:yn,meta:j(Et)})),rewards:R(D(Ye)),blockTime:j(f())}))),Un=U(j(S({blockhash:T(),previousBlockhash:T(),parentSlot:f(),signatures:D(T()),blockTime:j(f())}))),Bt=U(j(S({slot:f(),meta:j(Et),blockTime:R(j(f())),transaction:yn,version:R(st)}))),ft=U(j(S({slot:f(),transaction:ps,meta:j(wn),blockTime:R(j(f())),version:R(st)}))),Ji=ne(S({blockhash:T(),lastValidBlockHeight:f()})),Xi=ne(Ae()),eo=S({slot:f(),numTransactions:f(),numSlots:f(),samplePeriodSecs:f()}),to=U(D(eo)),no=ne(j(S({feeCalculator:S({lamportsPerSignature:f()})}))),so=U(T()),ro=U(T()),io=S({err:We,logs:D(T()),signature:T()}),oo=S({result:Lt(io),subscription:f()}),ao={"solana-client":"js/1.0.0-maintenance"};class co{constructor(e,t){this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionHashByClientSubscriptionId={},this._subscriptionStateChangeCallbacksByHash={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set,this.getBlockHeight=(()=>{const y={};return async m=>{const{commitment:I,config:z}=Z(m),L=this._buildArgs([],I,void 0,z),A=_n(L);return y[A]=y[A]??(async()=>{try{const p=await this._rpcRequest("getBlockHeight",L),b=E(p,U(f()));if("error"in b)throw new _(b.error,"failed to get block height information");return b.result}finally{delete y[A]}})(),await y[A]}})();let n,s,r,o,u,d;t&&typeof t=="string"?this._commitment=t:t&&(this._commitment=t.commitment,this._confirmTransactionInitialTimeout=t.confirmTransactionInitialTimeout,n=t.wsEndpoint,s=t.httpHeaders,r=t.fetch,o=t.fetchMiddleware,u=t.disableRetryOnRateLimit,d=t.httpAgent),this._rpcEndpoint=qr(e),this._rpcWsEndpoint=n||Kr(e),this._rpcClient=ai(e,s,r,o,u,d),this._rpcRequest=ci(this._rpcClient),this._rpcBatchRequest=ui(this._rpcClient),this._rpcWebSocket=new Pr(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}async getBalanceAndContext(e,t){const{commitment:n,config:s}=Z(t),r=this._buildArgs([e.toBase58()],n,void 0,s),o=await this._rpcRequest("getBalance",r),u=E(o,ne(f()));if("error"in u)throw new _(u.error,`failed to get balance for ${e.toBase58()}`);return u.result}async getBalance(e,t){return await this.getBalanceAndContext(e,t).then(n=>n.value).catch(n=>{throw new Error("failed to get balance of account "+e.toBase58()+": "+n)})}async getBlockTime(e){const t=await this._rpcRequest("getBlockTime",[e]),n=E(t,U(j(f())));if("error"in n)throw new _(n.error,`failed to get block time for slot ${e}`);return n.result}async getMinimumLedgerSlot(){const e=await this._rpcRequest("minimumLedgerSlot",[]),t=E(e,U(f()));if("error"in t)throw new _(t.error,"failed to get minimum ledger slot");return t.result}async getFirstAvailableBlock(){const e=await this._rpcRequest("getFirstAvailableBlock",[]),t=E(e,wi);if("error"in t)throw new _(t.error,"failed to get first available block");return t.result}async getSupply(e){let t={};typeof e=="string"?t={commitment:e}:e?t={...e,commitment:e&&e.commitment||this.commitment}:t={commitment:this.commitment};const n=await this._rpcRequest("getSupply",[t]),s=E(n,pi);if("error"in s)throw new _(s.error,"failed to get supply");return s.result}async getTokenSupply(e,t){const n=this._buildArgs([e.toBase58()],t),s=await this._rpcRequest("getTokenSupply",n),r=E(s,ne(Yt));if("error"in r)throw new _(r.error,"failed to get token supply");return r.result}async getTokenAccountBalance(e,t){const n=this._buildArgs([e.toBase58()],t),s=await this._rpcRequest("getTokenAccountBalance",n),r=E(s,ne(Yt));if("error"in r)throw new _(r.error,"failed to get token account balance");return r.result}async getTokenAccountsByOwner(e,t,n){const{commitment:s,config:r}=Z(n);let o=[e.toBase58()];"mint"in t?o.push({mint:t.mint.toBase58()}):o.push({programId:t.programId.toBase58()});const u=this._buildArgs(o,s,"base64",r),d=await this._rpcRequest("getTokenAccountsByOwner",u),y=E(d,mi);if("error"in y)throw new _(y.error,`failed to get token accounts owned by account ${e.toBase58()}`);return y.result}async getParsedTokenAccountsByOwner(e,t,n){let s=[e.toBase58()];"mint"in t?s.push({mint:t.mint.toBase58()}):s.push({programId:t.programId.toBase58()});const r=this._buildArgs(s,n,"jsonParsed"),o=await this._rpcRequest("getTokenAccountsByOwner",r),u=E(o,Si);if("error"in u)throw new _(u.error,`failed to get token accounts owned by account ${e.toBase58()}`);return u.result}async getLargestAccounts(e){const t={...e,commitment:e&&e.commitment||this.commitment},n=t.filter||t.commitment?[t]:[],s=await this._rpcRequest("getLargestAccounts",n),r=E(s,Ii);if("error"in r)throw new _(r.error,"failed to get largest accounts");return r.result}async getTokenLargestAccounts(e,t){const n=this._buildArgs([e.toBase58()],t),s=await this._rpcRequest("getTokenLargestAccounts",n),r=E(s,Mi);if("error"in r)throw new _(r.error,"failed to get token largest accounts");return r.result}async getAccountInfoAndContext(e,t){const{commitment:n,config:s}=Z(t),r=this._buildArgs([e.toBase58()],n,"base64",s),o=await this._rpcRequest("getAccountInfo",r),u=E(o,ne(j(lt)));if("error"in u)throw new _(u.error,`failed to get info about account ${e.toBase58()}`);return u.result}async getParsedAccountInfo(e,t){const{commitment:n,config:s}=Z(t),r=this._buildArgs([e.toBase58()],n,"jsonParsed",s),o=await this._rpcRequest("getAccountInfo",r),u=E(o,ne(j(Kt)));if("error"in u)throw new _(u.error,`failed to get info about account ${e.toBase58()}`);return u.result}async getAccountInfo(e,t){try{return(await this.getAccountInfoAndContext(e,t)).value}catch(n){throw new Error("failed to get info about account "+e.toBase58()+": "+n)}}async getMultipleParsedAccounts(e,t){const{commitment:n,config:s}=Z(t),r=e.map(y=>y.toBase58()),o=this._buildArgs([r],n,"jsonParsed",s),u=await this._rpcRequest("getMultipleAccounts",o),d=E(u,ne(D(j(Kt))));if("error"in d)throw new _(d.error,`failed to get info for accounts ${r}`);return d.result}async getMultipleAccountsInfoAndContext(e,t){const{commitment:n,config:s}=Z(t),r=e.map(y=>y.toBase58()),o=this._buildArgs([r],n,"base64",s),u=await this._rpcRequest("getMultipleAccounts",o),d=E(u,ne(D(j(lt))));if("error"in d)throw new _(d.error,`failed to get info for accounts ${r}`);return d.result}async getMultipleAccountsInfo(e,t){return(await this.getMultipleAccountsInfoAndContext(e,t)).value}async getStakeActivation(e,t,n){const{commitment:s,config:r}=Z(t),o=this._buildArgs([e.toBase58()],s,void 0,{...r,epoch:n??(r==null?void 0:r.epoch)}),u=await this._rpcRequest("getStakeActivation",o),d=E(u,U(Ti));if("error"in d)throw new _(d.error,`failed to get Stake Activation ${e.toBase58()}`);return d.result}async getProgramAccounts(e,t){const{commitment:n,config:s}=Z(t),{encoding:r,...o}=s||{},u=this._buildArgs([e.toBase58()],n,r||"base64",{...o,...o.filters?{filters:Rn(o.filters)}:null}),d=await this._rpcRequest("getProgramAccounts",u),y=D(bi),m=o.withContext===!0?E(d,ne(y)):E(d,U(y));if("error"in m)throw new _(m.error,`failed to get accounts owned by program ${e.toBase58()}`);return m.result}async getParsedProgramAccounts(e,t){const{commitment:n,config:s}=Z(t),r=this._buildArgs([e.toBase58()],n,"jsonParsed",s),o=await this._rpcRequest("getProgramAccounts",r),u=E(o,U(D(Ai)));if("error"in u)throw new _(u.error,`failed to get accounts owned by program ${e.toBase58()}`);return u.result}async confirmTransaction(e,t){var r;let n;if(typeof e=="string")n=e;else{const o=e;if((r=o.abortSignal)!=null&&r.aborted)return Promise.reject(o.abortSignal.reason);n=o.signature}let s;try{s=le.decode(n)}catch{throw new Error("signature must be base58 encoded: "+n)}return $(s.length===64,"signature has invalid length"),typeof e=="string"?await this.confirmTransactionUsingLegacyTimeoutStrategy({commitment:t||this.commitment,signature:n}):"lastValidBlockHeight"in e?await this.confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:t||this.commitment,strategy:e}):await this.confirmTransactionUsingDurableNonceStrategy({commitment:t||this.commitment,strategy:e})}getCancellationPromise(e){return new Promise((t,n)=>{e!=null&&(e.aborted?n(e.reason):e.addEventListener("abort",()=>{n(e.reason)}))})}getTransactionConfirmationPromise({commitment:e,signature:t}){let n,s,r=!1;const o=new Promise((d,y)=>{try{n=this.onSignature(t,(I,z)=>{n=void 0;const L={context:z,value:I};d({__type:_e.PROCESSED,response:L})},e);const m=new Promise(I=>{n==null?I():s=this._onSubscriptionStateChange(n,z=>{z==="subscribed"&&I()})});(async()=>{if(await m,r)return;const I=await this.getSignatureStatus(t);if(r||I==null)return;const{context:z,value:L}=I;if(L!=null)if(L!=null&&L.err)y(L.err);else{switch(e){case"confirmed":case"single":case"singleGossip":{if(L.confirmationStatus==="processed")return;break}case"finalized":case"max":case"root":{if(L.confirmationStatus==="processed"||L.confirmationStatus==="confirmed")return;break}case"processed":case"recent":}r=!0,d({__type:_e.PROCESSED,response:{context:z,value:L}})}})()}catch(m){y(m)}});return{abortConfirmation:()=>{s&&(s(),s=void 0),n!=null&&(this.removeSignatureListener(n),n=void 0)},confirmationPromise:o}}async confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:e,strategy:{abortSignal:t,lastValidBlockHeight:n,signature:s}}){let r=!1;const o=new Promise(I=>{const z=async()=>{try{return await this.getBlockHeight(e)}catch{return-1}};(async()=>{let L=await z();if(!r){for(;L<=n;)if(await Fe(1e3),r||(L=await z(),r))return;I({__type:_e.BLOCKHEIGHT_EXCEEDED})}})()}),{abortConfirmation:u,confirmationPromise:d}=this.getTransactionConfirmationPromise({commitment:e,signature:s}),y=this.getCancellationPromise(t);let m;try{const I=await Promise.race([y,d,o]);if(I.__type===_e.PROCESSED)m=I.response;else throw new rs(s)}finally{r=!0,u()}return m}async confirmTransactionUsingDurableNonceStrategy({commitment:e,strategy:{abortSignal:t,minContextSlot:n,nonceAccountPubkey:s,nonceValue:r,signature:o}}){let u=!1;const d=new Promise(L=>{let A=r,p=null;const b=async()=>{try{const{context:O,value:k}=await this.getNonceAndContext(s,{commitment:e,minContextSlot:n});return p=O.slot,k==null?void 0:k.nonce}catch{return A}};(async()=>{if(A=await b(),!u)for(;;){if(r!==A){L({__type:_e.NONCE_INVALID,slotInWhichNonceDidAdvance:p});return}if(await Fe(2e3),u||(A=await b(),u))return}})()}),{abortConfirmation:y,confirmationPromise:m}=this.getTransactionConfirmationPromise({commitment:e,signature:o}),I=this.getCancellationPromise(t);let z;try{const L=await Promise.race([I,m,d]);if(L.__type===_e.PROCESSED)z=L.response;else{let A;for(;;){const p=await this.getSignatureStatus(o);if(p==null)break;if(p.context.slot<(L.slotInWhichNonceDidAdvance??n)){await Fe(400);continue}A=p;break}if(A!=null&&A.value){const p=e||"finalized",{confirmationStatus:b}=A.value;switch(p){case"processed":case"recent":if(b!=="processed"&&b!=="confirmed"&&b!=="finalized")throw new ot(o);break;case"confirmed":case"single":case"singleGossip":if(b!=="confirmed"&&b!=="finalized")throw new ot(o);break;case"finalized":case"max":case"root":if(b!=="finalized")throw new ot(o);break;default:}z={context:A.context,value:{err:A.value.err}}}else throw new ot(o)}}finally{u=!0,y()}return z}async confirmTransactionUsingLegacyTimeoutStrategy({commitment:e,signature:t}){let n;const s=new Promise(d=>{let y=this._confirmTransactionInitialTimeout||6e4;switch(e){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":{y=this._confirmTransactionInitialTimeout||3e4;break}}n=setTimeout(()=>d({__type:_e.TIMED_OUT,timeoutMs:y}),y)}),{abortConfirmation:r,confirmationPromise:o}=this.getTransactionConfirmationPromise({commitment:e,signature:t});let u;try{const d=await Promise.race([o,s]);if(d.__type===_e.PROCESSED)u=d.response;else throw new is(t,d.timeoutMs/1e3)}finally{clearTimeout(n),r()}return u}async getClusterNodes(){const e=await this._rpcRequest("getClusterNodes",[]),t=E(e,U(D(Bi)));if("error"in t)throw new _(t.error,"failed to get cluster nodes");return t.result}async getVoteAccounts(e){const t=this._buildArgs([],e),n=await this._rpcRequest("getVoteAccounts",t),s=E(n,vi);if("error"in s)throw new _(s.error,"failed to get vote accounts");return s.result}async getSlot(e){const{commitment:t,config:n}=Z(e),s=this._buildArgs([],t,void 0,n),r=await this._rpcRequest("getSlot",s),o=E(r,U(f()));if("error"in o)throw new _(o.error,"failed to get slot");return o.result}async getSlotLeader(e){const{commitment:t,config:n}=Z(e),s=this._buildArgs([],t,void 0,n),r=await this._rpcRequest("getSlotLeader",s),o=E(r,U(T()));if("error"in o)throw new _(o.error,"failed to get slot leader");return o.result}async getSlotLeaders(e,t){const n=[e,t],s=await this._rpcRequest("getSlotLeaders",n),r=E(s,U(D(X)));if("error"in r)throw new _(r.error,"failed to get slot leaders");return r.result}async getSignatureStatus(e,t){const{context:n,value:s}=await this.getSignatureStatuses([e],t);$(s.length===1);const r=s[0];return{context:n,value:r}}async getSignatureStatuses(e,t){const n=[e];t&&n.push(t);const s=await this._rpcRequest("getSignatureStatuses",n),r=E(s,Wi);if("error"in r)throw new _(r.error,"failed to get signature status");return r.result}async getTransactionCount(e){const{commitment:t,config:n}=Z(e),s=this._buildArgs([],t,void 0,n),r=await this._rpcRequest("getTransactionCount",s),o=E(r,U(f()));if("error"in o)throw new _(o.error,"failed to get transaction count");return o.result}async getTotalSupply(e){return(await this.getSupply({commitment:e,excludeNonCirculatingAccountsList:!0})).value.total}async getInflationGovernor(e){const t=this._buildArgs([],e),n=await this._rpcRequest("getInflationGovernor",t),s=E(n,li);if("error"in s)throw new _(s.error,"failed to get inflation");return s.result}async getInflationReward(e,t,n){const{commitment:s,config:r}=Z(n),o=this._buildArgs([e.map(y=>y.toBase58())],s,void 0,{...r,epoch:t??(r==null?void 0:r.epoch)}),u=await this._rpcRequest("getInflationReward",o),d=E(u,Vr);if("error"in d)throw new _(d.error,"failed to get inflation reward");return d.result}async getInflationRate(){const e=await this._rpcRequest("getInflationRate",[]),t=E(e,di);if("error"in t)throw new _(t.error,"failed to get inflation rate");return t.result}async getEpochInfo(e){const{commitment:t,config:n}=Z(e),s=this._buildArgs([],t,void 0,n),r=await this._rpcRequest("getEpochInfo",s),o=E(r,fi);if("error"in o)throw new _(o.error,"failed to get epoch info");return o.result}async getEpochSchedule(){const e=await this._rpcRequest("getEpochSchedule",[]),t=E(e,gi);if("error"in t)throw new _(t.error,"failed to get epoch schedule");const n=t.result;return new vr(n.slotsPerEpoch,n.leaderScheduleSlotOffset,n.warmup,n.firstNormalEpoch,n.firstNormalSlot)}async getLeaderSchedule(){const e=await this._rpcRequest("getLeaderSchedule",[]),t=E(e,yi);if("error"in t)throw new _(t.error,"failed to get leader schedule");return t.result}async getMinimumBalanceForRentExemption(e,t){const n=this._buildArgs([e],t),s=await this._rpcRequest("getMinimumBalanceForRentExemption",n),r=E(s,Yi);return"error"in r?(console.warn("Unable to fetch minimum balance for rent exemption"),0):r.result}async getRecentBlockhashAndContext(e){const{context:t,value:{blockhash:n}}=await this.getLatestBlockhashAndContext(e);return{context:t,value:{blockhash:n,feeCalculator:{get lamportsPerSignature(){throw new Error("The capability to fetch `lamportsPerSignature` using the `getRecentBlockhash` API is no longer offered by the network. Use the `getFeeForMessage` API to obtain the fee for a given message.")},toJSON(){return{}}}}}}async getRecentPerformanceSamples(e){const t=await this._rpcRequest("getRecentPerformanceSamples",e?[e]:[]),n=E(t,to);if("error"in n)throw new _(n.error,"failed to get recent performance samples");return n.result}async getFeeCalculatorForBlockhash(e,t){const n=this._buildArgs([e],t),s=await this._rpcRequest("getFeeCalculatorForBlockhash",n),r=E(s,no);if("error"in r)throw new _(r.error,"failed to get fee calculator");const{context:o,value:u}=r.result;return{context:o,value:u!==null?u.feeCalculator:null}}async getFeeForMessage(e,t){const n=Je(e.serialize()).toString("base64"),s=this._buildArgs([n],t),r=await this._rpcRequest("getFeeForMessage",s),o=E(r,ne(j(f())));if("error"in o)throw new _(o.error,"failed to get fee for message");if(o.result===null)throw new Error("invalid blockhash");return o.result}async getRecentPrioritizationFees(e){var o;const t=(o=e==null?void 0:e.lockedWritableAccounts)==null?void 0:o.map(u=>u.toBase58()),n=t!=null&&t.length?[t]:[],s=await this._rpcRequest("getRecentPrioritizationFees",n),r=E(s,hi);if("error"in r)throw new _(r.error,"failed to get recent prioritization fees");return r.result}async getRecentBlockhash(e){try{return(await this.getRecentBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhash(e){try{return(await this.getLatestBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhashAndContext(e){const{commitment:t,config:n}=Z(e),s=this._buildArgs([],t,void 0,n),r=await this._rpcRequest("getLatestBlockhash",s),o=E(r,Ji);if("error"in o)throw new _(o.error,"failed to get latest blockhash");return o.result}async isBlockhashValid(e,t){const{commitment:n,config:s}=Z(t),r=this._buildArgs([e],n,void 0,s),o=await this._rpcRequest("isBlockhashValid",r),u=E(o,Xi);if("error"in u)throw new _(u.error,"failed to determine if the blockhash `"+e+"`is valid");return u.result}async getVersion(){const e=await this._rpcRequest("getVersion",[]),t=E(e,U(si));if("error"in t)throw new _(t.error,"failed to get version");return t.result}async getGenesisHash(){const e=await this._rpcRequest("getGenesisHash",[]),t=E(e,U(T()));if("error"in t)throw new _(t.error,"failed to get genesis hash");return t.result}async getBlock(e,t){const{commitment:n,config:s}=Z(t),r=this._buildArgsAtLeastConfirmed([e],n,void 0,s),o=await this._rpcRequest("getBlock",r);try{switch(s==null?void 0:s.transactionDetails){case"accounts":{const u=E(o,Gi);if("error"in u)throw u.error;return u.result}case"none":{const u=E(o,qi);if("error"in u)throw u.error;return u.result}default:{const u=E(o,Fi);if("error"in u)throw u.error;const{result:d}=u;return d?{...d,transactions:d.transactions.map(({transaction:y,meta:m,version:I})=>({meta:m,transaction:{...y,message:Rt(I,y.message)},version:I}))}:null}}}catch(u){throw new _(u,"failed to get confirmed block")}}async getParsedBlock(e,t){const{commitment:n,config:s}=Z(t),r=this._buildArgsAtLeastConfirmed([e],n,"jsonParsed",s),o=await this._rpcRequest("getBlock",r);try{switch(s==null?void 0:s.transactionDetails){case"accounts":{const u=E(o,Vi);if("error"in u)throw u.error;return u.result}case"none":{const u=E(o,Zi);if("error"in u)throw u.error;return u.result}default:{const u=E(o,Hi);if("error"in u)throw u.error;return u.result}}}catch(u){throw new _(u,"failed to get block")}}async getBlockProduction(e){let t,n;if(typeof e=="string")n=e;else if(e){const{commitment:u,...d}=e;n=u,t=d}const s=this._buildArgs([],n,"base64",t),r=await this._rpcRequest("getBlockProduction",s),o=E(r,oi);if("error"in o)throw new _(o.error,"failed to get block production information");return o.result}async getTransaction(e,t){const{commitment:n,config:s}=Z(t),r=this._buildArgsAtLeastConfirmed([e],n,void 0,s),o=await this._rpcRequest("getTransaction",r),u=E(o,Bt);if("error"in u)throw new _(u.error,"failed to get transaction");const d=u.result;return d&&{...d,transaction:{...d.transaction,message:Rt(d.version,d.transaction.message)}}}async getParsedTransaction(e,t){const{commitment:n,config:s}=Z(t),r=this._buildArgsAtLeastConfirmed([e],n,"jsonParsed",s),o=await this._rpcRequest("getTransaction",r),u=E(o,ft);if("error"in u)throw new _(u.error,"failed to get transaction");return u.result}async getParsedTransactions(e,t){const{commitment:n,config:s}=Z(t),r=e.map(d=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([d],n,"jsonParsed",s)}));return(await this._rpcBatchRequest(r)).map(d=>{const y=E(d,ft);if("error"in y)throw new _(y.error,"failed to get transactions");return y.result})}async getTransactions(e,t){const{commitment:n,config:s}=Z(t),r=e.map(d=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([d],n,void 0,s)}));return(await this._rpcBatchRequest(r)).map(d=>{const y=E(d,Bt);if("error"in y)throw new _(y.error,"failed to get transactions");const m=y.result;return m&&{...m,transaction:{...m.transaction,message:Rt(m.version,m.transaction.message)}}})}async getConfirmedBlock(e,t){const n=this._buildArgsAtLeastConfirmed([e],t),s=await this._rpcRequest("getBlock",n),r=E(s,$i);if("error"in r)throw new _(r.error,"failed to get confirmed block");const o=r.result;if(!o)throw new Error("Confirmed block "+e+" not found");const u={...o,transactions:o.transactions.map(({transaction:d,meta:y})=>{const m=new je(d.message);return{meta:y,transaction:{...d,message:m}}})};return{...u,transactions:u.transactions.map(({transaction:d,meta:y})=>({meta:y,transaction:Ne.populate(d.message,d.signatures)}))}}async getBlocks(e,t,n){const s=this._buildArgsAtLeastConfirmed(t!==void 0?[e,t]:[e],n),r=await this._rpcRequest("getBlocks",s),o=E(r,U(D(f())));if("error"in o)throw new _(o.error,"failed to get blocks");return o.result}async getBlockSignatures(e,t){const n=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),s=await this._rpcRequest("getBlock",n),r=E(s,Un);if("error"in r)throw new _(r.error,"failed to get block");const o=r.result;if(!o)throw new Error("Block "+e+" not found");return o}async getConfirmedBlockSignatures(e,t){const n=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),s=await this._rpcRequest("getBlock",n),r=E(s,Un);if("error"in r)throw new _(r.error,"failed to get confirmed block");const o=r.result;if(!o)throw new Error("Confirmed block "+e+" not found");return o}async getConfirmedTransaction(e,t){const n=this._buildArgsAtLeastConfirmed([e],t),s=await this._rpcRequest("getTransaction",n),r=E(s,Bt);if("error"in r)throw new _(r.error,"failed to get transaction");const o=r.result;if(!o)return o;const u=new je(o.transaction.message),d=o.transaction.signatures;return{...o,transaction:Ne.populate(u,d)}}async getParsedConfirmedTransaction(e,t){const n=this._buildArgsAtLeastConfirmed([e],t,"jsonParsed"),s=await this._rpcRequest("getTransaction",n),r=E(s,ft);if("error"in r)throw new _(r.error,"failed to get confirmed transaction");return r.result}async getParsedConfirmedTransactions(e,t){const n=e.map(o=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([o],t,"jsonParsed")}));return(await this._rpcBatchRequest(n)).map(o=>{const u=E(o,ft);if("error"in u)throw new _(u.error,"failed to get confirmed transactions");return u.result})}async getConfirmedSignaturesForAddress(e,t,n){let s={},r=await this.getFirstAvailableBlock();for(;!("until"in s)&&(t--,!(t<=0||t<r));)try{const d=await this.getConfirmedBlockSignatures(t,"finalized");d.signatures.length>0&&(s.until=d.signatures[d.signatures.length-1].toString())}catch(d){if(d instanceof Error&&d.message.includes("skipped"))continue;throw d}let o=await this.getSlot("finalized");for(;!("before"in s)&&(n++,!(n>o));)try{const d=await this.getConfirmedBlockSignatures(n);d.signatures.length>0&&(s.before=d.signatures[d.signatures.length-1].toString())}catch(d){if(d instanceof Error&&d.message.includes("skipped"))continue;throw d}return(await this.getConfirmedSignaturesForAddress2(e,s)).map(d=>d.signature)}async getConfirmedSignaturesForAddress2(e,t,n){const s=this._buildArgsAtLeastConfirmed([e.toBase58()],n,void 0,t),r=await this._rpcRequest("getConfirmedSignaturesForAddress2",s),o=E(r,Li);if("error"in o)throw new _(o.error,"failed to get confirmed signatures for address");return o.result}async getSignaturesForAddress(e,t,n){const s=this._buildArgsAtLeastConfirmed([e.toBase58()],n,void 0,t),r=await this._rpcRequest("getSignaturesForAddress",s),o=E(r,Ei);if("error"in o)throw new _(o.error,"failed to get signatures for address");return o.result}async getAddressLookupTable(e,t){const{context:n,value:s}=await this.getAccountInfoAndContext(e,t);let r=null;return s!==null&&(r=new Cn({key:e,state:Cn.deserialize(s.data)})),{context:n,value:r}}async getNonceAndContext(e,t){const{context:n,value:s}=await this.getAccountInfoAndContext(e,t);let r=null;return s!==null&&(r=fn.fromAccountData(s.data)),{context:n,value:r}}async getNonce(e,t){return await this.getNonceAndContext(e,t).then(n=>n.value).catch(n=>{throw new Error("failed to get nonce for account "+e.toBase58()+": "+n)})}async requestAirdrop(e,t){const n=await this._rpcRequest("requestAirdrop",[e.toBase58(),t]),s=E(n,so);if("error"in s)throw new _(s.error,`airdrop to ${e.toBase58()} failed`);return s.result}async _blockhashWithExpiryBlockHeight(e){if(!e){for(;this._pollingBlockhash;)await Fe(100);const n=Date.now()-this._blockhashInfo.lastFetch>=Fr;if(this._blockhashInfo.latestBlockhash!==null&&!n)return this._blockhashInfo.latestBlockhash}return await this._pollNewBlockhash()}async _pollNewBlockhash(){this._pollingBlockhash=!0;try{const e=Date.now(),t=this._blockhashInfo.latestBlockhash,n=t?t.blockhash:null;for(let s=0;s<50;s++){const r=await this.getLatestBlockhash("finalized");if(n!==r.blockhash)return this._blockhashInfo={latestBlockhash:r,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},r;await Fe(xr/2)}throw new Error(`Unable to obtain a new blockhash after ${Date.now()-e}ms`)}finally{this._pollingBlockhash=!1}}async getStakeMinimumDelegation(e){const{commitment:t,config:n}=Z(e),s=this._buildArgs([],t,"base64",n),r=await this._rpcRequest("getStakeMinimumDelegation",s),o=E(r,ne(f()));if("error"in o)throw new _(o.error,"failed to get stake minimum delegation");return o.result}async simulateTransaction(e,t,n){if("message"in e){const p=e.serialize(),b=P.Buffer.from(p).toString("base64");if(Array.isArray(t)||n!==void 0)throw new Error("Invalid arguments");const O=t||{};O.encoding="base64","commitment"in O||(O.commitment=this.commitment),t&&typeof t=="object"&&"innerInstructions"in t&&(O.innerInstructions=t.innerInstructions);const k=[b,O],v=await this._rpcRequest("simulateTransaction",k),q=E(v,Bn);if("error"in q)throw new Error("failed to simulate transaction: "+q.error.message);return q.result}let s;if(e instanceof Ne){let A=e;s=new Ne,s.feePayer=A.feePayer,s.instructions=e.instructions,s.nonceInfo=A.nonceInfo,s.signatures=A.signatures}else s=Ne.populate(e),s._message=s._json=void 0;if(t!==void 0&&!Array.isArray(t))throw new Error("Invalid arguments");const r=t;if(s.nonceInfo&&r)s.sign(...r);else{let A=this._disableBlockhashCaching;for(;;){const p=await this._blockhashWithExpiryBlockHeight(A);if(s.lastValidBlockHeight=p.lastValidBlockHeight,s.recentBlockhash=p.blockhash,!r)break;if(s.sign(...r),!s.signature)throw new Error("!signature");const b=s.signature.toString("base64");if(!this._blockhashInfo.simulatedSignatures.includes(b)&&!this._blockhashInfo.transactionSignatures.includes(b)){this._blockhashInfo.simulatedSignatures.push(b);break}else A=!0}}const o=s._compile(),u=o.serialize(),y=s._serialize(u).toString("base64"),m={encoding:"base64",commitment:this.commitment};if(n){const A=(Array.isArray(n)?n:o.nonProgramIds()).map(p=>p.toBase58());m.accounts={encoding:"base64",addresses:A}}r&&(m.sigVerify=!0),t&&typeof t=="object"&&"innerInstructions"in t&&(m.innerInstructions=t.innerInstructions);const I=[y,m],z=await this._rpcRequest("simulateTransaction",I),L=E(z,Bn);if("error"in L){let A;if("data"in L.error&&(A=L.error.data.logs,A&&Array.isArray(A))){const p=`
    `,b=p+A.join(p);console.error(L.error.message,b)}throw new kn({action:"simulate",signature:"",transactionMessage:L.error.message,logs:A})}return L.result}async sendTransaction(e,t,n){if("version"in e){if(t&&Array.isArray(t))throw new Error("Invalid arguments");const o=e.serialize();return await this.sendRawTransaction(o,t)}if(t===void 0||!Array.isArray(t))throw new Error("Invalid arguments");const s=t;if(e.nonceInfo)e.sign(...s);else{let o=this._disableBlockhashCaching;for(;;){const u=await this._blockhashWithExpiryBlockHeight(o);if(e.lastValidBlockHeight=u.lastValidBlockHeight,e.recentBlockhash=u.blockhash,e.sign(...s),!e.signature)throw new Error("!signature");const d=e.signature.toString("base64");if(this._blockhashInfo.transactionSignatures.includes(d))o=!0;else{this._blockhashInfo.transactionSignatures.push(d);break}}}const r=e.serialize();return await this.sendRawTransaction(r,n)}async sendRawTransaction(e,t){const n=Je(e).toString("base64");return await this.sendEncodedTransaction(n,t)}async sendEncodedTransaction(e,t){const n={encoding:"base64"},s=t&&t.skipPreflight,r=s===!0?"processed":t&&t.preflightCommitment||this.commitment;t&&t.maxRetries!=null&&(n.maxRetries=t.maxRetries),t&&t.minContextSlot!=null&&(n.minContextSlot=t.minContextSlot),s&&(n.skipPreflight=s),r&&(n.preflightCommitment=r);const o=[e,n],u=await this._rpcRequest("sendTransaction",o),d=E(u,ro);if("error"in d){let y;throw"data"in d.error&&(y=d.error.data.logs),new kn({action:s?"send":"simulate",signature:"",transactionMessage:d.error.message,logs:y})}return d.result}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval(()=>{(async()=>{try{await this._rpcWebSocket.notify("ping")}catch{}})()},5e3),this._updateSubscriptions()}_wsOnError(e){this._rpcWebSocketConnected=!1,console.error("ws error:",e.message)}_wsOnClose(e){if(this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration=(this._rpcWebSocketGeneration+1)%Number.MAX_SAFE_INTEGER,this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null),this._rpcWebSocketHeartbeat&&(clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null),e===1e3){this._updateSubscriptions();return}this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach(([t,n])=>{this._setSubscription(t,{...n,state:"pending"})})}_setSubscription(e,t){var s;const n=(s=this._subscriptionsByHash[e])==null?void 0:s.state;if(this._subscriptionsByHash[e]=t,n!==t.state){const r=this._subscriptionStateChangeCallbacksByHash[e];r&&r.forEach(o=>{try{o(t.state)}catch{}})}}_onSubscriptionStateChange(e,t){var r;const n=this._subscriptionHashByClientSubscriptionId[e];if(n==null)return()=>{};const s=(r=this._subscriptionStateChangeCallbacksByHash)[n]||(r[n]=new Set);return s.add(t),()=>{s.delete(t),s.size===0&&delete this._subscriptionStateChangeCallbacksByHash[n]}}async _updateSubscriptions(){if(Object.keys(this._subscriptionsByHash).length===0){this._rpcWebSocketConnected&&(this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout(()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(n){n instanceof Error&&console.log(`Error when closing socket connection: ${n.message}`)}},500));return}if(this._rpcWebSocketIdleTimeout!==null&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0),!this._rpcWebSocketConnected){this._rpcWebSocket.connect();return}const e=this._rpcWebSocketGeneration,t=()=>e===this._rpcWebSocketGeneration;await Promise.all(Object.keys(this._subscriptionsByHash).map(async n=>{const s=this._subscriptionsByHash[n];if(s!==void 0)switch(s.state){case"pending":case"unsubscribed":if(s.callbacks.size===0){delete this._subscriptionsByHash[n],s.state==="unsubscribed"&&delete this._subscriptionCallbacksByServerSubscriptionId[s.serverSubscriptionId],await this._updateSubscriptions();return}await(async()=>{const{args:r,method:o}=s;try{this._setSubscription(n,{...s,state:"subscribing"});const u=await this._rpcWebSocket.call(o,r);this._setSubscription(n,{...s,serverSubscriptionId:u,state:"subscribed"}),this._subscriptionCallbacksByServerSubscriptionId[u]=s.callbacks,await this._updateSubscriptions()}catch(u){if(console.error(`Received ${u instanceof Error?"":"JSON-RPC "}error calling \`${o}\``,{args:r,error:u}),!t())return;this._setSubscription(n,{...s,state:"pending"}),await this._updateSubscriptions()}})();break;case"subscribed":s.callbacks.size===0&&await(async()=>{const{serverSubscriptionId:r,unsubscribeMethod:o}=s;if(this._subscriptionsAutoDisposedByRpc.has(r))this._subscriptionsAutoDisposedByRpc.delete(r);else{this._setSubscription(n,{...s,state:"unsubscribing"}),this._setSubscription(n,{...s,state:"unsubscribing"});try{await this._rpcWebSocket.call(o,[r])}catch(u){if(u instanceof Error&&console.error(`${o} error:`,u.message),!t())return;this._setSubscription(n,{...s,state:"subscribed"}),await this._updateSubscriptions();return}}this._setSubscription(n,{...s,state:"unsubscribed"}),await this._updateSubscriptions()})();break}}))}_handleServerNotification(e,t){const n=this._subscriptionCallbacksByServerSubscriptionId[e];n!==void 0&&n.forEach(s=>{try{s(...t)}catch(r){console.error(r)}})}_wsOnAccountNotification(e){const{result:t,subscription:n}=E(e,Di);this._handleServerNotification(n,[t.value,t.context])}_makeSubscription(e,t){const n=this._nextClientSubscriptionId++,s=_n([e.method,t]),r=this._subscriptionsByHash[s];return r===void 0?this._subscriptionsByHash[s]={...e,args:t,callbacks:new Set([e.callback]),state:"pending"}:r.callbacks.add(e.callback),this._subscriptionHashByClientSubscriptionId[n]=s,this._subscriptionDisposeFunctionsByClientSubscriptionId[n]=async()=>{delete this._subscriptionDisposeFunctionsByClientSubscriptionId[n],delete this._subscriptionHashByClientSubscriptionId[n];const o=this._subscriptionsByHash[s];$(o!==void 0,`Could not find a \`Subscription\` when tearing down client subscription #${n}`),o.callbacks.delete(e.callback),await this._updateSubscriptions()},this._updateSubscriptions(),n}onAccountChange(e,t,n){const{commitment:s,config:r}=Z(n),o=this._buildArgs([e.toBase58()],s||this._commitment||"finalized","base64",r);return this._makeSubscription({callback:t,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},o)}async removeAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"account change")}_wsOnProgramAccountNotification(e){const{result:t,subscription:n}=E(e,zi);this._handleServerNotification(n,[{accountId:t.value.pubkey,accountInfo:t.value.account},t.context])}onProgramAccountChange(e,t,n,s){const{commitment:r,config:o}=Z(n),u=this._buildArgs([e.toBase58()],r||this._commitment||"finalized","base64",o||(s?{filters:Rn(s)}:void 0));return this._makeSubscription({callback:t,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},u)}async removeProgramAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"program account change")}onLogs(e,t,n){const s=this._buildArgs([typeof e=="object"?{mentions:[e.toString()]}:e],n||this._commitment||"finalized");return this._makeSubscription({callback:t,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},s)}async removeOnLogsListener(e){await this._unsubscribeClientSubscription(e,"logs")}_wsOnLogsNotification(e){const{result:t,subscription:n}=E(e,oo);this._handleServerNotification(n,[t.value,t.context])}_wsOnSlotNotification(e){const{result:t,subscription:n}=E(e,xi);this._handleServerNotification(n,[t])}onSlotChange(e){return this._makeSubscription({callback:e,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}async removeSlotChangeListener(e){await this._unsubscribeClientSubscription(e,"slot change")}_wsOnSlotUpdatesNotification(e){const{result:t,subscription:n}=E(e,Oi);this._handleServerNotification(n,[t])}onSlotUpdate(e){return this._makeSubscription({callback:e,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}async removeSlotUpdateListener(e){await this._unsubscribeClientSubscription(e,"slot update")}async _unsubscribeClientSubscription(e,t){const n=this._subscriptionDisposeFunctionsByClientSubscriptionId[e];n?await n():console.warn(`Ignored unsubscribe request because an active subscription with id \`${e}\` for '${t}' events could not be found.`)}_buildArgs(e,t,n,s){const r=t||this._commitment;if(r||n||s){let o={};n&&(o.encoding=n),r&&(o.commitment=r),s&&(o=Object.assign(o,s)),e.push(o)}return e}_buildArgsAtLeastConfirmed(e,t,n,s){const r=t||this._commitment;if(r&&!["confirmed","finalized"].includes(r))throw new Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(e,t,n,s)}_wsOnSignatureNotification(e){const{result:t,subscription:n}=E(e,Ci);t.value!=="receivedSignature"&&this._subscriptionsAutoDisposedByRpc.add(n),this._handleServerNotification(n,t.value==="receivedSignature"?[{type:"received"},t.context]:[{type:"status",result:t.value},t.context])}onSignature(e,t,n){const s=this._buildArgs([e],n||this._commitment||"finalized"),r=this._makeSubscription({callback:(o,u)=>{if(o.type==="status"){t(o.result,u);try{this.removeSignatureListener(r)}catch{}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},s);return r}onSignatureWithOptions(e,t,n){const{commitment:s,...r}={...n,commitment:n&&n.commitment||this._commitment||"finalized"},o=this._buildArgs([e],s,void 0,r),u=this._makeSubscription({callback:(d,y)=>{t(d,y);try{this.removeSignatureListener(u)}catch{}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},o);return u}async removeSignatureListener(e){await this._unsubscribeClientSubscription(e,"signature result")}_wsOnRootNotification(e){const{result:t,subscription:n}=E(e,Ri);this._handleServerNotification(n,[t])}onRootChange(e){return this._makeSubscription({callback:e,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}async removeRootChangeListener(e){await this._unsubscribeClientSubscription(e,"root change")}}Object.freeze({CreateLookupTable:{index:0,layout:l.struct([l.u32("instruction"),Xe("recentSlot"),l.u8("bumpSeed")])},FreezeLookupTable:{index:1,layout:l.struct([l.u32("instruction")])},ExtendLookupTable:{index:2,layout:l.struct([l.u32("instruction"),Xe(),l.seq(W(),l.offset(l.u32(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:l.struct([l.u32("instruction")])},CloseLookupTable:{index:4,layout:l.struct([l.u32("instruction")])}});new C("AddressLookupTab1e1111111111111111111111111");Object.freeze({RequestUnits:{index:0,layout:l.struct([l.u8("instruction"),l.u32("units"),l.u32("additionalFee")])},RequestHeapFrame:{index:1,layout:l.struct([l.u8("instruction"),l.u32("bytes")])},SetComputeUnitLimit:{index:2,layout:l.struct([l.u8("instruction"),l.u32("units")])},SetComputeUnitPrice:{index:3,layout:l.struct([l.u8("instruction"),Xe("microLamports")])}});new C("ComputeBudget111111111111111111111111111111");l.struct([l.u8("numSignatures"),l.u8("padding"),l.u16("signatureOffset"),l.u16("signatureInstructionIndex"),l.u16("publicKeyOffset"),l.u16("publicKeyInstructionIndex"),l.u16("messageDataOffset"),l.u16("messageDataSize"),l.u16("messageInstructionIndex")]);new C("Ed25519SigVerify111111111111111111111111111");Ps.utils.isValidPrivateKey;l.struct([l.u8("numSignatures"),l.u16("signatureOffset"),l.u8("signatureInstructionIndex"),l.u16("ethAddressOffset"),l.u8("ethAddressInstructionIndex"),l.u16("messageDataOffset"),l.u16("messageDataSize"),l.u8("messageInstructionIndex"),l.blob(20,"ethAddress"),l.blob(64,"signature"),l.u8("recoveryId")]);new C("KeccakSecp256k11111111111111111111111111111");var ms;new C("StakeConfig11111111111111111111111111111111");class Ss{constructor(e,t,n){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=e,this.epoch=t,this.custodian=n}}ms=Ss;Ss.default=new ms(0,0,C.default);Object.freeze({Initialize:{index:0,layout:l.struct([l.u32("instruction"),Ar(),Tr()])},Authorize:{index:1,layout:l.struct([l.u32("instruction"),W("newAuthorized"),l.u32("stakeAuthorizationType")])},Delegate:{index:2,layout:l.struct([l.u32("instruction")])},Split:{index:3,layout:l.struct([l.u32("instruction"),l.ns64("lamports")])},Withdraw:{index:4,layout:l.struct([l.u32("instruction"),l.ns64("lamports")])},Deactivate:{index:5,layout:l.struct([l.u32("instruction")])},Merge:{index:7,layout:l.struct([l.u32("instruction")])},AuthorizeWithSeed:{index:8,layout:l.struct([l.u32("instruction"),W("newAuthorized"),l.u32("stakeAuthorizationType"),Ge("authoritySeed"),W("authorityOwner")])}});new C("Stake11111111111111111111111111111111111111");Object.freeze({InitializeAccount:{index:0,layout:l.struct([l.u32("instruction"),Lr()])},Authorize:{index:1,layout:l.struct([l.u32("instruction"),W("newAuthorized"),l.u32("voteAuthorizationType")])},Withdraw:{index:3,layout:l.struct([l.u32("instruction"),l.ns64("lamports")])},UpdateValidatorIdentity:{index:4,layout:l.struct([l.u32("instruction")])},AuthorizeWithSeed:{index:10,layout:l.struct([l.u32("instruction"),Er()])}});new C("Vote111111111111111111111111111111111111111");new C("Va1idator1nfo111111111111111111111111111111");S({name:T(),website:R(T()),details:R(T()),iconUrl:R(T()),keybaseUsername:R(T())});new C("Vote111111111111111111111111111111111111111");l.struct([W("nodePubkey"),W("authorizedWithdrawer"),l.u8("commission"),l.nu64(),l.seq(l.struct([l.nu64("slot"),l.u32("confirmationCount")]),l.offset(l.u32(),-8),"votes"),l.u8("rootSlotValid"),l.nu64("rootSlot"),l.nu64(),l.seq(l.struct([l.nu64("epoch"),W("authorizedVoter")]),l.offset(l.u32(),-8),"authorizedVoters"),l.struct([l.seq(l.struct([W("authorizedPubkey"),l.nu64("epochOfLastAuthorizedSwitch"),l.nu64("targetEpoch")]),32,"buf"),l.nu64("idx"),l.u8("isEmpty")],"priorVoters"),l.nu64(),l.seq(l.struct([l.nu64("epoch"),l.nu64("credits"),l.nu64("prevCredits")]),l.offset(l.u32(),-8),"epochCredits"),l.struct([l.nu64("slot"),l.nu64("timestamp")],"lastTimestamp")]);const Pn={http:{devnet:"http://api.devnet.solana.com",testnet:"http://api.testnet.solana.com","mainnet-beta":"http://api.mainnet-beta.solana.com/"},https:{devnet:"https://api.devnet.solana.com",testnet:"https://api.testnet.solana.com","mainnet-beta":"https://api.mainnet-beta.solana.com/"}};function ta(i,e){const t="https";if(!i)return Pn[t].devnet;const n=Pn[t][i];if(!n)throw new Error(`Unknown ${t} cluster: ${i}`);return n}const Is=B.createContext({});function uo(){return B.useContext(Is)}const na=({children:i,endpoint:e,config:t={commitment:"confirmed"}})=>{const n=B.useMemo(()=>new co(e,t),[e,t]);return on.createElement(Is.Provider,{value:{connection:n}},i)};class ce extends Error{constructor(e,t){super(e),this.error=t}}class et extends ce{constructor(){super(...arguments),this.name="WalletNotReadyError"}}class lo extends ce{constructor(){super(...arguments),this.name="WalletLoadError"}}class He extends ce{constructor(){super(...arguments),this.name="WalletConfigError"}}class bt extends ce{constructor(){super(...arguments),this.name="WalletConnectionError"}}class Dt extends ce{constructor(){super(...arguments),this.name="WalletDisconnectedError"}}class pn extends ce{constructor(){super(...arguments),this.name="WalletDisconnectionError"}}class Oe extends ce{constructor(){super(...arguments),this.name="WalletAccountError"}}class tt extends ce{constructor(){super(...arguments),this.name="WalletPublicKeyError"}}class te extends ce{constructor(){super(...arguments),this.name="WalletNotConnectedError"}}class Ce extends ce{constructor(){super(...arguments),this.name="WalletSendTransactionError"}}class Ie extends ce{constructor(){super(...arguments),this.name="WalletSignTransactionError"}}class Mn extends ce{constructor(){super(...arguments),this.name="WalletSignMessageError"}}class Wn extends ce{constructor(){super(...arguments),this.name="WalletSignInError"}}var Q;(function(i){i.Installed="Installed",i.NotDetected="NotDetected",i.Loadable="Loadable",i.Unsupported="Unsupported"})(Q||(Q={}));class bs extends Us{get connected(){return!!this.publicKey}async autoConnect(){await this.connect()}async prepareTransaction(e,t,n={}){const s=this.publicKey;if(!s)throw new te;return e.feePayer=e.feePayer||s,e.recentBlockhash=e.recentBlockhash||(await t.getLatestBlockhash({commitment:n.preflightCommitment,minContextSlot:n.minContextSlot})).blockhash,e}}function mn(i){if(typeof window>"u"||typeof document>"u")return;const e=[];function t(){if(i())for(const r of e)r()}const n=setInterval(t,1e3);e.push(()=>clearInterval(n)),document.readyState==="loading"&&(document.addEventListener("DOMContentLoaded",t,{once:!0}),e.push(()=>document.removeEventListener("DOMContentLoaded",t))),document.readyState!=="complete"&&(window.addEventListener("load",t,{once:!0}),e.push(()=>window.removeEventListener("load",t))),t()}function Ft(){if(!navigator)return!1;const i=navigator.userAgent.toLowerCase(),e=i.includes("iphone")||i.includes("ipad"),t=i.includes("safari");return e&&t}function De(i){return"version"in i}class Ns extends bs{async sendTransaction(e,t,n={}){let s=!0;try{if(De(e)){if(!this.supportedTransactionVersions)throw new Ce("Sending versioned transactions isn't supported by this wallet");if(!this.supportedTransactionVersions.has(e.version))throw new Ce(`Sending transaction version ${e.version} isn't supported by this wallet`);try{e=await this.signTransaction(e);const r=e.serialize();return await t.sendRawTransaction(r,n)}catch(r){throw r instanceof Ie?(s=!1,r):new Ce(r==null?void 0:r.message,r)}}else try{const{signers:r,...o}=n;e=await this.prepareTransaction(e,t,o),r!=null&&r.length&&e.partialSign(...r),e=await this.signTransaction(e);const u=e.serialize();return await t.sendRawTransaction(u,o)}catch(r){throw r instanceof Ie?(s=!1,r):new Ce(r==null?void 0:r.message,r)}}catch(r){throw s&&this.emit("error",r),r}}async signAllTransactions(e){for(const n of e)if(De(n)){if(!this.supportedTransactionVersions)throw new Ie("Signing versioned transactions isn't supported by this wallet");if(!this.supportedTransactionVersions.has(n.version))throw new Ie(`Signing transaction version ${n.version} isn't supported by this wallet`)}const t=[];for(const n of e)t.push(await this.signTransaction(n));return t}}class Sn extends Ns{}class sa extends Sn{}const Ee="solana:signAndSendTransaction",vt="solana:signIn",qe="solana:signMessage",ae="solana:signTransaction";function ho(i){return an in i.features&&cn in i.features&&(Ee in i.features||ae in i.features)}var Yn;(function(i){i.Mainnet="mainnet-beta",i.Testnet="testnet",i.Devnet="devnet"})(Yn||(Yn={}));class Qn extends ce{constructor(){super(...arguments),this.name="WalletNotSelectedError"}}const fo=[],jt={autoConnect:!1,connecting:!1,connected:!1,disconnecting:!1,select(){be("call","select")},connect(){return Promise.reject(be("call","connect"))},disconnect(){return Promise.reject(be("call","disconnect"))},sendTransaction(){return Promise.reject(be("call","sendTransaction"))},signTransaction(){return Promise.reject(be("call","signTransaction"))},signAllTransactions(){return Promise.reject(be("call","signAllTransactions"))},signMessage(){return Promise.reject(be("call","signMessage"))},signIn(){return Promise.reject(be("call","signIn"))}};Object.defineProperty(jt,"wallets",{get(){return be("read","wallets"),fo}});Object.defineProperty(jt,"wallet",{get(){return be("read","wallet"),null}});Object.defineProperty(jt,"publicKey",{get(){return be("read","publicKey"),null}});function be(i,e){const t=new Error(`You have tried to ${i} "${e}" on a WalletContext without providing one. Make sure to render a WalletProvider as an ancestor of the component that uses WalletContext.`);return console.error(t),t}const As=B.createContext(jt);function ra(){return B.useContext(As)}function go(i,e){const t=B.useState(()=>{try{const r=localStorage.getItem(i);if(r)return JSON.parse(r)}catch(r){typeof window<"u"&&console.error(r)}return e}),n=t[0],s=B.useRef(!0);return B.useEffect(()=>{if(s.current){s.current=!1;return}try{n===null?localStorage.removeItem(i):localStorage.setItem(i,JSON.stringify(n))}catch(r){typeof window<"u"&&console.error(r)}},[n,i]),t}function Ut(i){switch(i){case"processed":case"confirmed":case"finalized":case void 0:return i;case"recent":return"processed";case"single":case"singleGossip":return"confirmed";case"max":case"root":return"finalized";default:return}}const qt="solana:mainnet",Ts="solana:devnet",Ls="solana:testnet",yo="solana:localnet",wo="https://api.mainnet-beta.solana.com";function po(i){return i.includes(wo)?qt:/\bdevnet\b/i.test(i)?Ts:/\btestnet\b/i.test(i)?Ls:/\blocalhost\b/i.test(i)||/\b127\.0\.0\.1\b/.test(i)?yo:qt}function ia(i){let e=`${i.domain} wants you to sign in with your Solana account:
`;e+=`${i.address}`,i.statement&&(e+=`

${i.statement}`);const t=[];if(i.uri&&t.push(`URI: ${i.uri}`),i.version&&t.push(`Version: ${i.version}`),i.chainId&&t.push(`Chain ID: ${i.chainId}`),i.nonce&&t.push(`Nonce: ${i.nonce}`),i.issuedAt&&t.push(`Issued At: ${i.issuedAt}`),i.expirationTime&&t.push(`Expiration Time: ${i.expirationTime}`),i.notBefore&&t.push(`Not Before: ${i.notBefore}`),i.requestId&&t.push(`Request ID: ${i.requestId}`),i.resources){t.push("Resources:");for(const n of i.resources)t.push(`- ${n}`)}return t.length&&(e+=`

${t.join(`
`)}`),e}function Mo(i){if(i.length>=255)throw new TypeError("Alphabet too long");const e=new Uint8Array(256);for(let y=0;y<e.length;y++)e[y]=255;for(let y=0;y<i.length;y++){const m=i.charAt(y),I=m.charCodeAt(0);if(e[I]!==255)throw new TypeError(m+" is ambiguous");e[I]=y}const t=i.length,n=i.charAt(0),s=Math.log(t)/Math.log(256),r=Math.log(256)/Math.log(t);function o(y){if(y instanceof Uint8Array||(ArrayBuffer.isView(y)?y=new Uint8Array(y.buffer,y.byteOffset,y.byteLength):Array.isArray(y)&&(y=Uint8Array.from(y))),!(y instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(y.length===0)return"";let m=0,I=0,z=0;const L=y.length;for(;z!==L&&y[z]===0;)z++,m++;const A=(L-z)*r+1>>>0,p=new Uint8Array(A);for(;z!==L;){let k=y[z],v=0;for(let q=A-1;(k!==0||v<I)&&q!==-1;q--,v++)k+=256*p[q]>>>0,p[q]=k%t>>>0,k=k/t>>>0;if(k!==0)throw new Error("Non-zero carry");I=v,z++}let b=A-I;for(;b!==A&&p[b]===0;)b++;let O=n.repeat(m);for(;b<A;++b)O+=i.charAt(p[b]);return O}function u(y){if(typeof y!="string")throw new TypeError("Expected String");if(y.length===0)return new Uint8Array;let m=0,I=0,z=0;for(;y[m]===n;)I++,m++;const L=(y.length-m)*s+1>>>0,A=new Uint8Array(L);for(;m<y.length;){const k=y.charCodeAt(m);if(k>255)return;let v=e[k];if(v===255)return;let q=0;for(let ie=L-1;(v!==0||q<z)&&ie!==-1;ie--,q++)v+=t*A[ie]>>>0,A[ie]=v%256>>>0,v=v/256>>>0;if(v!==0)throw new Error("Non-zero carry");z=q,m++}let p=L-z;for(;p!==L&&A[p]===0;)p++;const b=new Uint8Array(I+(L-p));let O=I;for(;p!==L;)b[O++]=A[p++];return b}function d(y){const m=u(y);if(m)return m;throw new Error("Non-base"+t+" character")}return{encode:o,decodeUnsafe:u,decode:d}}var mo="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";const So=Mo(mo);var x=function(i,e,t,n){if(t==="a"&&!n)throw new TypeError("Private accessor was defined without a getter");if(typeof e=="function"?i!==e||!n:!e.has(i))throw new TypeError("Cannot read private member from an object whose class did not declare it");return t==="m"?n:t==="a"?n.call(i):n?n.value:e.get(i)},re=function(i,e,t,n,s){if(n==="m")throw new TypeError("Private method is not writable");if(n==="a"&&!s)throw new TypeError("Private accessor was defined without a setter");if(typeof e=="function"?i!==e||!s:!e.has(i))throw new TypeError("Cannot write private member to an object whose class did not declare it");return n==="a"?s.call(i,t):s?s.value=t:e.set(i,t),t},ue,ye,ve,Ue,Be,at,Nt,F,At,Gt,wt,Ht,ct,Vt,Kn,Fn,qn,Gn;class Io extends bs{get name(){return x(this,F,"f").name}get url(){return"https://github.com/solana-labs/wallet-standard"}get icon(){return x(this,F,"f").icon}get readyState(){return x(this,At,"f")}get publicKey(){return x(this,ve,"f")}get connecting(){return x(this,Ue,"f")}get supportedTransactionVersions(){return x(this,Nt,"f")}get wallet(){return x(this,F,"f")}get standard(){return!0}constructor({wallet:e}){super(),ue.add(this),ye.set(this,void 0),ve.set(this,void 0),Ue.set(this,void 0),Be.set(this,void 0),at.set(this,void 0),Nt.set(this,void 0),F.set(this,void 0),At.set(this,typeof window>"u"||typeof document>"u"?Q.Unsupported:Q.Installed),Vt.set(this,t=>{if("accounts"in t){const n=x(this,F,"f").accounts[0];x(this,ye,"f")&&!x(this,Be,"f")&&n!==x(this,ye,"f")&&(n?x(this,ue,"m",wt).call(this,n):(this.emit("error",new Dt),x(this,ue,"m",Ht).call(this)))}"features"in t&&x(this,ue,"m",ct).call(this)}),re(this,F,e,"f"),re(this,ye,null,"f"),re(this,ve,null,"f"),re(this,Ue,!1,"f"),re(this,Be,!1,"f"),re(this,at,x(this,F,"f").features[cn].on("change",x(this,Vt,"f")),"f"),x(this,ue,"m",ct).call(this)}destroy(){re(this,ye,null,"f"),re(this,ve,null,"f"),re(this,Ue,!1,"f"),re(this,Be,!1,"f");const e=x(this,at,"f");e&&(re(this,at,null,"f"),e())}async autoConnect(){return x(this,ue,"m",Gt).call(this,{silent:!0})}async connect(){return x(this,ue,"m",Gt).call(this)}async disconnect(){if(Wt in x(this,F,"f").features)try{re(this,Be,!0,"f"),await x(this,F,"f").features[Wt].disconnect()}catch(e){this.emit("error",new pn(e==null?void 0:e.message,e))}finally{re(this,Be,!1,"f")}x(this,ue,"m",Ht).call(this)}async sendTransaction(e,t,n={}){try{const s=x(this,ye,"f");if(!s)throw new te;let r;if(Ee in x(this,F,"f").features)if(s.features.includes(Ee))r=Ee;else if(ae in x(this,F,"f").features&&s.features.includes(ae))r=ae;else throw new Oe;else if(ae in x(this,F,"f").features){if(!s.features.includes(ae))throw new Oe;r=ae}else throw new He;const o=po(t.rpcEndpoint);if(!s.chains.includes(o))throw new Ce;try{const{signers:u,...d}=n;let y;if(De(e)?(u!=null&&u.length&&e.sign(u),y=e.serialize()):(e=await this.prepareTransaction(e,t,d),u!=null&&u.length&&e.partialSign(...u),y=new Uint8Array(e.serialize({requireAllSignatures:!1,verifySignatures:!1}))),r===Ee){const[m]=await x(this,F,"f").features[Ee].signAndSendTransaction({account:s,chain:o,transaction:y,options:{preflightCommitment:Ut(d.preflightCommitment||t.commitment),skipPreflight:d.skipPreflight,maxRetries:d.maxRetries,minContextSlot:d.minContextSlot}});return So.encode(m.signature)}else{const[m]=await x(this,F,"f").features[ae].signTransaction({account:s,chain:o,transaction:y,options:{preflightCommitment:Ut(d.preflightCommitment||t.commitment),minContextSlot:d.minContextSlot}});return await t.sendRawTransaction(m.signedTransaction,{...d,preflightCommitment:Ut(d.preflightCommitment||t.commitment)})}}catch(u){throw u instanceof ce?u:new Ce(u==null?void 0:u.message,u)}}catch(s){throw this.emit("error",s),s}}}ye=new WeakMap,ve=new WeakMap,Ue=new WeakMap,Be=new WeakMap,at=new WeakMap,Nt=new WeakMap,F=new WeakMap,At=new WeakMap,Vt=new WeakMap,ue=new WeakSet,Gt=async function(e){try{if(this.connected||this.connecting)return;if(x(this,At,"f")!==Q.Installed)throw new et;if(re(this,Ue,!0,"f"),!x(this,F,"f").accounts.length)try{await x(this,F,"f").features[an].connect(e)}catch(n){throw new bt(n==null?void 0:n.message,n)}const t=x(this,F,"f").accounts[0];if(!t)throw new Oe;x(this,ue,"m",wt).call(this,t)}catch(t){throw this.emit("error",t),t}finally{re(this,Ue,!1,"f")}},wt=function(e){let t;try{t=new C(e.address)}catch(n){throw new tt(n==null?void 0:n.message,n)}re(this,ye,e,"f"),re(this,ve,t,"f"),x(this,ue,"m",ct).call(this),this.emit("connect",t)},Ht=function(){re(this,ye,null,"f"),re(this,ve,null,"f"),x(this,ue,"m",ct).call(this),this.emit("disconnect")},ct=function(){var t,n;const e=Ee in x(this,F,"f").features?x(this,F,"f").features[Ee].supportedTransactionVersions:x(this,F,"f").features[ae].supportedTransactionVersions;re(this,Nt,Cs(e,["legacy"])?null:new Set(e),"f"),ae in x(this,F,"f").features&&((t=x(this,ye,"f"))!=null&&t.features.includes(ae))?(this.signTransaction=x(this,ue,"m",Kn),this.signAllTransactions=x(this,ue,"m",Fn)):(delete this.signTransaction,delete this.signAllTransactions),qe in x(this,F,"f").features&&((n=x(this,ye,"f"))!=null&&n.features.includes(qe))?this.signMessage=x(this,ue,"m",qn):delete this.signMessage,vt in x(this,F,"f").features?this.signIn=x(this,ue,"m",Gn):delete this.signIn},Kn=async function(e){try{const t=x(this,ye,"f");if(!t)throw new te;if(!(ae in x(this,F,"f").features))throw new He;if(!t.features.includes(ae))throw new Oe;try{const s=(await x(this,F,"f").features[ae].signTransaction({account:t,transaction:De(e)?e.serialize():new Uint8Array(e.serialize({requireAllSignatures:!1,verifySignatures:!1}))}))[0].signedTransaction;return De(e)?St.deserialize(s):Ne.from(s)}catch(n){throw n instanceof ce?n:new Ie(n==null?void 0:n.message,n)}}catch(t){throw this.emit("error",t),t}},Fn=async function(e){try{const t=x(this,ye,"f");if(!t)throw new te;if(!(ae in x(this,F,"f").features))throw new He;if(!t.features.includes(ae))throw new Oe;try{const n=await x(this,F,"f").features[ae].signTransaction(...e.map(s=>({account:t,transaction:De(s)?s.serialize():new Uint8Array(s.serialize({requireAllSignatures:!1,verifySignatures:!1}))})));return e.map((s,r)=>{const o=n[r].signedTransaction;return De(s)?St.deserialize(o):Ne.from(o)})}catch(n){throw new Ie(n==null?void 0:n.message,n)}}catch(t){throw this.emit("error",t),t}},qn=async function(e){try{const t=x(this,ye,"f");if(!t)throw new te;if(!(qe in x(this,F,"f").features))throw new He;if(!t.features.includes(qe))throw new Oe;try{return(await x(this,F,"f").features[qe].signMessage({account:t,message:e}))[0].signature}catch(n){throw new Mn(n==null?void 0:n.message,n)}}catch(t){throw this.emit("error",t),t}},Gn=async function(e={}){try{if(!(vt in x(this,F,"f").features))throw new He;let t;try{[t]=await x(this,F,"f").features[vt].signIn(e)}catch(n){throw new Wn(n==null?void 0:n.message,n)}if(!t)throw new Wn;return x(this,ue,"m",wt).call(this,t.account),t}catch(t){throw this.emit("error",t),t}};const bo=ho;function No(i){const e=Hn(()=>new Set),{get:t,on:n}=Hn(()=>Rs()),[s,r]=B.useState(()=>Vn(t()));B.useEffect(()=>{const u=[n("register",(...d)=>r(y=>[...y,...Vn(d)])),n("unregister",(...d)=>r(y=>y.filter(m=>d.some(I=>I===m.wallet))))];return()=>u.forEach(d=>d())},[n]);const o=Ao(s);return B.useEffect(()=>{if(!o)return;const u=new Set(s);new Set(o.filter(y=>!u.has(y))).forEach(y=>y.destroy())},[o,s]),B.useEffect(()=>()=>s.forEach(u=>u.destroy()),[]),B.useMemo(()=>[...s,...i.filter(({name:u})=>s.some(d=>d.name===u)?(e.has(u)||(e.add(u),console.warn(`${u} was registered as a Standard Wallet. The Wallet Adapter for ${u} can be removed from your app.`)),!1):!0)],[s,i,e])}function Hn(i){const e=B.useRef(void 0);return e.current===void 0&&(e.current={value:i()}),e.current.value}function Ao(i){const e=B.useRef(void 0);return B.useEffect(()=>{e.current=i}),e.current}function Vn(i){return i.filter(bo).map(e=>new Io({wallet:e}))}var $e;(function(i){i[i.DESKTOP_WEB=0]="DESKTOP_WEB",i[i.MOBILE_WEB=1]="MOBILE_WEB"})($e||($e={}));function To(i){return/(WebView|Version\/.+(Chrome)\/(\d+)\.(\d+)\.(\d+)\.(\d+)|; wv\).+(Chrome)\/(\d+)\.(\d+)\.(\d+)\.(\d+))/i.test(i)}function Lo({adapters:i,userAgentString:e}){return i.some(t=>t.name!==gt&&t.readyState===Q.Installed)?$e.DESKTOP_WEB:e&&/android/i.test(e)&&!To(e)?$e.MOBILE_WEB:$e.DESKTOP_WEB}function Eo(i){return i?/devnet/i.test(i)?"devnet":/testnet/i.test(i)?"testnet":"mainnet-beta":"mainnet-beta"}function Do({children:i,wallets:e,adapter:t,isUnloadingRef:n,onAutoConnectRequest:s,onConnectError:r,onError:o,onSelectWallet:u}){const d=B.useRef(!1),[y,m]=B.useState(!1),I=B.useRef(!1),[z,L]=B.useState(!1),[A,p]=B.useState(()=>(t==null?void 0:t.publicKey)??null),[b,O]=B.useState(()=>(t==null?void 0:t.connected)??!1),k=B.useRef(o);B.useEffect(()=>(k.current=o,()=>{k.current=void 0}),[o]);const v=B.useRef((Y,V)=>(n.current||(k.current?k.current(Y,V):(console.error(Y,V),Y instanceof et&&typeof window<"u"&&V&&window.open(V.url,"_blank"))),Y)),[q,ie]=B.useState(()=>e.map(Y=>({adapter:Y,readyState:Y.readyState})).filter(({readyState:Y})=>Y!==Q.Unsupported));B.useEffect(()=>{ie(V=>e.map((ee,we)=>{const Te=V[we];return Te&&Te.adapter===ee&&Te.readyState===ee.readyState?Te:{adapter:ee,readyState:ee.readyState}}).filter(({readyState:ee})=>ee!==Q.Unsupported));function Y(V){ie(ee=>{const we=ee.findIndex(({adapter:Qe})=>Qe===this);if(we===-1)return ee;const{adapter:Te}=ee[we];return[...ee.slice(0,we),{adapter:Te,readyState:V},...ee.slice(we+1)].filter(({readyState:Qe})=>Qe!==Q.Unsupported)})}return e.forEach(V=>V.on("readyStateChange",Y,V)),()=>{e.forEach(V=>V.off("readyStateChange",Y,V))}},[t,e]);const K=B.useMemo(()=>q.find(Y=>Y.adapter===t)??null,[t,q]);B.useEffect(()=>{if(!t)return;const Y=we=>{p(we),d.current=!1,m(!1),O(!0),I.current=!1,L(!1)},V=()=>{n.current||(p(null),d.current=!1,m(!1),O(!1),I.current=!1,L(!1))},ee=we=>{v.current(we,t)};return t.on("connect",Y),t.on("disconnect",V),t.on("error",ee),()=>{t.off("connect",Y),t.off("disconnect",V),t.off("error",ee),V()}},[t,n]);const fe=B.useRef(!1);B.useEffect(()=>()=>{fe.current=!1},[t]),B.useEffect(()=>{fe.current||d.current||b||!s||!((K==null?void 0:K.readyState)===Q.Installed||(K==null?void 0:K.readyState)===Q.Loadable)||(d.current=!0,m(!0),fe.current=!0,async function(){try{await s()}catch{r()}finally{m(!1),d.current=!1}}())},[b,s,r,K]);const ge=B.useCallback(async(Y,V,ee)=>{if(!t)throw v.current(new Qn);if(!b)throw v.current(new te,t);return await t.sendTransaction(Y,V,ee)},[t,b]),oe=B.useMemo(()=>t&&"signTransaction"in t?async Y=>{if(!b)throw v.current(new te,t);return await t.signTransaction(Y)}:void 0,[t,b]),Se=B.useMemo(()=>t&&"signAllTransactions"in t?async Y=>{if(!b)throw v.current(new te,t);return await t.signAllTransactions(Y)}:void 0,[t,b]),ze=B.useMemo(()=>t&&"signMessage"in t?async Y=>{if(!b)throw v.current(new te,t);return await t.signMessage(Y)}:void 0,[t,b]),rt=B.useMemo(()=>t&&"signIn"in t?async Y=>await t.signIn(Y):void 0,[t]),ht=B.useCallback(async()=>{if(d.current||I.current||K!=null&&K.adapter.connected)return;if(!K)throw v.current(new Qn);const{adapter:Y,readyState:V}=K;if(!(V===Q.Installed||V===Q.Loadable))throw v.current(new et,Y);d.current=!0,m(!0);try{await Y.connect()}catch(ee){throw r(),ee}finally{m(!1),d.current=!1}},[r,K]),ke=B.useCallback(async()=>{if(!I.current&&t){I.current=!0,L(!0);try{await t.disconnect()}finally{L(!1),I.current=!1}}},[t]);return on.createElement(As.Provider,{value:{autoConnect:!!s,wallets:q,wallet:K,publicKey:A,connected:b,connecting:y,disconnecting:z,select:u,connect:ht,disconnect:ke,sendTransaction:ge,signTransaction:oe,signAllTransactions:Se,signMessage:ze,signIn:rt}},i)}let Pt;function jo(){var i;return Pt===void 0&&(Pt=((i=globalThis.navigator)==null?void 0:i.userAgent)??null),Pt}function Zn(i){const e=jo();return Lo({adapters:i,userAgentString:e})===$e.MOBILE_WEB}function zo(){const i=globalThis.location;if(i)return`${i.protocol}//${i.host}`}function oa({children:i,wallets:e,autoConnect:t,localStorageKey:n="walletName",onError:s}){const{connection:r}=uo(),o=No(e),u=B.useMemo(()=>{if(!Zn(o))return null;const k=o.find(v=>v.name===gt);return k||new ks({addressSelector:Os(),appIdentity:{uri:zo()},authorizationResultCache:_s(),cluster:Eo(r==null?void 0:r.rpcEndpoint),onWalletNotFound:xs()})},[o,r==null?void 0:r.rpcEndpoint]),d=B.useMemo(()=>u==null||o.indexOf(u)!==-1?o:[u,...o],[o,u]),[y,m]=go(n,null),I=B.useMemo(()=>d.find(k=>k.name===y)??null,[d,y]),z=B.useCallback(k=>{y!==k&&(I&&I.name!==gt&&I.disconnect(),m(k))},[I,m,y]);B.useEffect(()=>{if(!I)return;function k(){p.current||m(null)}return I.on("disconnect",k),()=>{I.off("disconnect",k)}},[I,o,m,y]);const L=B.useRef(!1),A=B.useMemo(()=>{if(!(!t||!I))return async()=>{(t===!0||await t(I))&&(L.current?await I.connect():await I.autoConnect())}},[t,I]),p=B.useRef(!1);B.useEffect(()=>{if(y===gt&&Zn(o)){p.current=!1;return}function k(){p.current=!0}return window.addEventListener("beforeunload",k),()=>{window.removeEventListener("beforeunload",k)}},[o,y]);const b=B.useCallback(()=>{I&&z(null)},[I,z]),O=B.useCallback(k=>{L.current=!0,z(k)},[z]);return on.createElement(Do,{wallets:d,adapter:I,isUnloadingRef:p,onAutoConnectRequest:A,onConnectError:b,onError:s,onSelectWallet:O},i)}const ko="MathWallet";class aa extends Ns{constructor(e={}){super(),this.name=ko,this.url="https://mathwallet.org",this.icon="data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjEyOCIgdmlld0JveD0iMCAwIDEyOCAxMjgiIHdpZHRoPSIxMjgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iI2ZmZiIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJtMCAwaDEyOHYxMjhoLTEyOHoiIG9wYWNpdHk9IjAiLz48cGF0aCBkPSJtOTAuODQ3MDA4NiA1Ny43NjEwMDIzYy0yLjI3NzAzNjMtMi4yNzcwMzYzLTIuMjc3MDM2My01Ljk2ODg0MTYgMC04LjI0NTg3NzggMi4yNzcwMzYyLTIuMjc3MDM2MyA1Ljk2ODg0MTUtMi4yNzcwMzYzIDguMjQ1ODc3OCAwIDIuMjc3MDM2NiAyLjI3NzAzNjIgMi4yNzcwMzY2IDUuOTY4ODQxNSAwIDguMjQ1ODc3OC0yLjI3NzAzNjMgMi4yNzcwMzYyLTUuOTY4ODQxNiAyLjI3NzAzNjItOC4yNDU4Nzc4IDB6bS0xOS41ODM5NTk4IDE5LjU4Mzk1OTdjLTEuNzA3Nzc3Mi0xLjcwNzc3NzItMS43MDc3NzcyLTQuNDc2NjMxMSAwLTYuMTg0NDA4M3M0LjQ3NjYzMTEtMS43MDc3NzcyIDYuMTg0NDA4MyAwIDEuNzA3Nzc3MiA0LjQ3NjYzMTEgMCA2LjE4NDQwODMtNC40NzY2MzExIDEuNzA3Nzc3Mi02LjE4NDQwODMgMHptMzAuOTIyMDQyMi0xMC4zMDczNDcyYy0xLjcwNzc3OC0xLjcwNzc3NzItMS43MDc3NzgtNC40NzY2MzEyIDAtNi4xODQ0MDg0IDEuNzA3Nzc3LTEuNzA3Nzc3MiA0LjQ3NjYzMS0xLjcwNzc3NzIgNi4xODQ0MDggMHMxLjcwNzc3NyA0LjQ3NjYzMTIgMCA2LjE4NDQwODQtNC40NzY2MzEgMS43MDc3NzcyLTYuMTg0NDA4IDB6bS0xMC4zMDczNDc3IDEwLjMwNzM0NzJjLTEuNzA3Nzc3Mi0xLjcwNzc3NzItMS43MDc3NzcyLTQuNDc2NjMxMSAwLTYuMTg0NDA4M3M0LjQ3NjYzMTEtMS43MDc3NzcyIDYuMTg0NDA4MyAwIDEuNzA3Nzc3MiA0LjQ3NjYzMTEgMCA2LjE4NDQwODMtNC40NzY2MzExIDEuNzA3Nzc3Mi02LjE4NDQwODMgMHptMjEuNjQ1NDI4Ny0xLjAzMDczNDdjLTEuMTM4NTE4LTEuMTM4NTE4MS0xLjEzODUxOC0yLjk4NDQyMDggMC00LjEyMjkzODkgMS4xMzg1MTktMS4xMzg1MTgxIDIuOTg0NDIxLTEuMTM4NTE4MSA0LjEyMjkzOSAwIDEuMTM4NTE5IDEuMTM4NTE4MSAxLjEzODUxOSAyLjk4NDQyMDggMCA0LjEyMjkzODktMS4xMzg1MTggMS4xMzg1MTgxLTIuOTg0NDIgMS4xMzg1MTgxLTQuMTIyOTM5IDB6bS0xMC4zMDczNDcgMTAuMzA3MzQ3MmMtMS4xMzg1MTgtMS4xMzg1MTgxLTEuMTM4NTE4LTIuOTg0NDIwNyAwLTQuMTIyOTM4OSAxLjEzODUxOC0xLjEzODUxODEgMi45ODQ0MjEtMS4xMzg1MTgxIDQuMTIyOTM5IDAgMS4xMzg1MTggMS4xMzg1MTgyIDEuMTM4NTE4IDIuOTg0NDIwOCAwIDQuMTIyOTM4OS0xLjEzODUxOCAxLjEzODUxODItMi45ODQ0MjEgMS4xMzg1MTgyLTQuMTIyOTM5IDB6bS0yMi42NzYxNjM3LTE4LjU1MzIyNWMtMi4yNzcwMzYzLTIuMjc3MDM2My0yLjI3NzAzNjMtNS45Njg4NDE1IDAtOC4yNDU4Nzc4czUuOTY4ODQxNS0yLjI3NzAzNjMgOC4yNDU4Nzc4IDAgMi4yNzcwMzYzIDUuOTY4ODQxNSAwIDguMjQ1ODc3OC01Ljk2ODg0MTUgMi4yNzcwMzYzLTguMjQ1ODc3OCAwem0wLTIwLjYxNDY5NDVjLTIuMjc3MDM2My0yLjI3NzAzNjMtMi4yNzcwMzYzLTUuOTY4ODQxNSAwLTguMjQ1ODc3OHM1Ljk2ODg0MTUtMi4yNzcwMzYzIDguMjQ1ODc3OCAwIDIuMjc3MDM2MyA1Ljk2ODg0MTUgMCA4LjI0NTg3NzgtNS45Njg4NDE1IDIuMjc3MDM2My04LjI0NTg3NzggMHptLTEwLjMwNzM0NzIgMTAuMzA3MzQ3M2MtMi4yNzcwMzYzLTIuMjc3MDM2My0yLjI3NzAzNjMtNS45Njg4NDE2IDAtOC4yNDU4Nzc4IDIuMjc3MDM2Mi0yLjI3NzAzNjMgNS45Njg4NDE1LTIuMjc3MDM2MyA4LjI0NTg3NzggMCAyLjI3NzAzNjIgMi4yNzcwMzYyIDIuMjc3MDM2MiA1Ljk2ODg0MTUgMCA4LjI0NTg3NzgtMi4yNzcwMzYzIDIuMjc3MDM2Mi01Ljk2ODg0MTYgMi4yNzcwMzYyLTguMjQ1ODc3OCAwem0tMjAuNzEwNTA2IDBjLTIuMjc3MDM2Mi0yLjI3NzAzNjMtMi4yNzcwMzYyLTUuOTY4ODQxNiAwLTguMjQ1ODc3OCAyLjI3NzAzNjMtMi4yNzcwMzYzIDUuOTY4ODQxNi0yLjI3NzAzNjMgOC4yNDU4Nzc4IDAgMi4yNzcwMzYzIDIuMjc3MDM2MiAyLjI3NzAzNjMgNS45Njg4NDE1IDAgOC4yNDU4Nzc4LTIuMjc3MDM2MiAyLjI3NzAzNjItNS45Njg4NDE1IDIuMjc3MDM2Mi04LjI0NTg3NzggMHptLTE5LjU4Mzk1OTcgMTkuNTgzOTU5N2MtMS43MDc3NzcyLTEuNzA3Nzc3Mi0xLjcwNzc3NzItNC40NzY2MzExIDAtNi4xODQ0MDgzczQuNDc2NjMxMS0xLjcwNzc3NzIgNi4xODQ0MDgzIDAgMS43MDc3NzcyIDQuNDc2NjMxMSAwIDYuMTg0NDA4My00LjQ3NjYzMTEgMS43MDc3NzcyLTYuMTg0NDA4MyAwem0zMC45MjIwNDE3LTEwLjMwNzM0NzJjLTEuNzA3Nzc3Mi0xLjcwNzc3NzItMS43MDc3NzcyLTQuNDc2NjMxMiAwLTYuMTg0NDA4NHM0LjQ3NjYzMTItMS43MDc3NzcyIDYuMTg0NDA4NCAwIDEuNzA3Nzc3MiA0LjQ3NjYzMTIgMCA2LjE4NDQwODQtNC40NzY2MzEyIDEuNzA3Nzc3Mi02LjE4NDQwODQgMHptLTEwLjMwNzM0NzIgMTAuMzA3MzQ3MmMtMS43MDc3NzcyLTEuNzA3Nzc3Mi0xLjcwNzc3NzItNC40NzY2MzExIDAtNi4xODQ0MDgzczQuNDc2NjMxMS0xLjcwNzc3NzIgNi4xODQ0MDgzIDAgMS43MDc3NzcyIDQuNDc2NjMxMSAwIDYuMTg0NDA4My00LjQ3NjYzMTEgMS43MDc3NzcyLTYuMTg0NDA4MyAwem0tNDAuMTk4NjU0My0xLjAzMDczNDdjLTEuMTM4NTE4MTMtMS4xMzg1MTgxLTEuMTM4NTE4MTMtMi45ODQ0MjA4IDAtNC4xMjI5Mzg5IDEuMTM4NTE4MS0xLjEzODUxODEgMi45ODQ0MjA4LTEuMTM4NTE4MSA0LjEyMjkzODkgMHMxLjEzODUxODEgMi45ODQ0MjA4IDAgNC4xMjI5Mzg5LTIuOTg0NDIwOCAxLjEzODUxODEtNC4xMjI5Mzg5IDB6bTEwLjMwNzM0NzMgMTAuMzA3MzQ3MmMtMS4xMzg1MTgyLTEuMTM4NTE4MS0xLjEzODUxODItMi45ODQ0MjA3IDAtNC4xMjI5Mzg5IDEuMTM4NTE4MS0xLjEzODUxODEgMi45ODQ0MjA3LTEuMTM4NTE4MSA0LjEyMjkzODggMCAxLjEzODUxODIgMS4xMzg1MTgyIDEuMTM4NTE4MiAyLjk4NDQyMDggMCA0LjEyMjkzODktMS4xMzg1MTgxIDEuMTM4NTE4Mi0yLjk4NDQyMDcgMS4xMzg1MTgyLTQuMTIyOTM4OCAwem00MS4yMjkzODg5IDBjLTEuMTM4NTE4MS0xLjEzODUxODEtMS4xMzg1MTgxLTIuOTg0NDIwNyAwLTQuMTIyOTM4OSAxLjEzODUxODItMS4xMzg1MTgxIDIuOTg0NDIwOC0xLjEzODUxODEgNC4xMjI5Mzg5IDAgMS4xMzg1MTgyIDEuMTM4NTE4MiAxLjEzODUxODIgMi45ODQ0MjA4IDAgNC4xMjI5Mzg5LTEuMTM4NTE4MSAxLjEzODUxODItMi45ODQ0MjA3IDEuMTM4NTE4Mi00LjEyMjkzODkgMHptLTQyLjI2MDEyMzctMTkuNTgzOTU5N2MtMS43MDc3NzcyLTEuNzA3Nzc3Mi0xLjcwNzc3NzItNC40NzY2MzEyIDAtNi4xODQ0MDg0czQuNDc2NjMxMi0xLjcwNzc3NzIgNi4xODQ0MDg0IDAgMS43MDc3NzcyIDQuNDc2NjMxMiAwIDYuMTg0NDA4NC00LjQ3NjYzMTIgMS43MDc3NzcyLTYuMTg0NDA4NCAwem0xOS41ODM5NTk4IDEuMDMwNzM0N2MtMi4yNzcwMzYzLTIuMjc3MDM2My0yLjI3NzAzNjMtNS45Njg4NDE1IDAtOC4yNDU4Nzc4czUuOTY4ODQxNS0yLjI3NzAzNjMgOC4yNDU4Nzc4IDAgMi4yNzcwMzYzIDUuOTY4ODQxNSAwIDguMjQ1ODc3OC01Ljk2ODg0MTUgMi4yNzcwMzYzLTguMjQ1ODc3OCAwem0wLTIwLjYxNDY5NDVjLTIuMjc3MDM2My0yLjI3NzAzNjMtMi4yNzcwMzYzLTUuOTY4ODQxNSAwLTguMjQ1ODc3OHM1Ljk2ODg0MTUtMi4yNzcwMzYzIDguMjQ1ODc3OCAwIDIuMjc3MDM2MyA1Ljk2ODg0MTUgMCA4LjI0NTg3NzgtNS45Njg4NDE1IDIuMjc3MDM2My04LjI0NTg3NzggMHptLTEwLjMwNzM0NzMgMTAuMzA3MzQ3M2MtMi4yNzcwMzYyLTIuMjc3MDM2My0yLjI3NzAzNjItNS45Njg4NDE2IDAtOC4yNDU4Nzc4IDIuMjc3MDM2My0yLjI3NzAzNjMgNS45Njg4NDE2LTIuMjc3MDM2MyA4LjI0NTg3NzggMCAyLjI3NzAzNjMgMi4yNzcwMzYyIDIuMjc3MDM2MyA1Ljk2ODg0MTUgMCA4LjI0NTg3NzgtMi4yNzcwMzYyIDIuMjc3MDM2Mi01Ljk2ODg0MTUgMi4yNzcwMzYyLTguMjQ1ODc3OCAweiIvPjwvZz48L3N2Zz4=",this.supportedTransactionVersions=null,this._readyState=typeof window>"u"||typeof document>"u"?Q.Unsupported:Q.NotDetected,this._messaged=t=>{const n=t.data;n&&n.origin==="mathwallet_internal"&&n.type==="lockStatusChanged"&&!n.payload&&this._disconnected()},this._disconnected=()=>{this._wallet&&(window.removeEventListener("message",this._messaged),this._wallet=null,this._publicKey=null,this.emit("error",new Dt),this.emit("disconnect"))},this._connecting=!1,this._wallet=null,this._publicKey=null,this._readyState!==Q.Unsupported&&mn(()=>{var t;return(t=window.solana)!=null&&t.isMathWallet?(this._readyState=Q.Installed,this.emit("readyStateChange",this._readyState),!0):!1})}get publicKey(){return this._publicKey}get connecting(){return this._connecting}get readyState(){return this._readyState}async connect(){try{if(this.connected||this.connecting)return;if(this._readyState!==Q.Installed)throw new et;this._connecting=!0;const e=window.solana;let t;try{t=await e.getAccount()}catch(s){throw new Oe(s==null?void 0:s.message,s)}let n;try{n=new C(t)}catch(s){throw new tt(s==null?void 0:s.message,s)}window.addEventListener("message",this._messaged),this._wallet=e,this._publicKey=n,this.emit("connect",n)}catch(e){throw this.emit("error",e),e}finally{this._connecting=!1}}async disconnect(){this._wallet&&(window.removeEventListener("message",this._messaged),this._wallet=null,this._publicKey=null),this.emit("disconnect")}async signTransaction(e){try{const t=this._wallet;if(!t)throw new te;try{return await t.signTransaction(e)||e}catch(n){throw new Ie(n==null?void 0:n.message,n)}}catch(t){throw this.emit("error",t),t}}async signAllTransactions(e){try{const t=this._wallet;if(!t)throw new te;try{return await t.signAllTransactions(e)||e}catch(n){throw new Ie(n==null?void 0:n.message,n)}}catch(t){throw this.emit("error",t),t}}}const xo="Phantom";class ca extends Sn{constructor(e={}){super(),this.name=xo,this.url="https://phantom.app",this.icon="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDgiIGhlaWdodD0iMTA4IiB2aWV3Qm94PSIwIDAgMTA4IDEwOCIgZmlsbD0ibm9uZSI+CjxyZWN0IHdpZHRoPSIxMDgiIGhlaWdodD0iMTA4IiByeD0iMjYiIGZpbGw9IiNBQjlGRjIiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00Ni41MjY3IDY5LjkyMjlDNDIuMDA1NCA3Ni44NTA5IDM0LjQyOTIgODUuNjE4MiAyNC4zNDggODUuNjE4MkMxOS41ODI0IDg1LjYxODIgMTUgODMuNjU2MyAxNSA3NS4xMzQyQzE1IDUzLjQzMDUgNDQuNjMyNiAxOS44MzI3IDcyLjEyNjggMTkuODMyN0M4Ny43NjggMTkuODMyNyA5NCAzMC42ODQ2IDk0IDQzLjAwNzlDOTQgNTguODI1OCA4My43MzU1IDc2LjkxMjIgNzMuNTMyMSA3Ni45MTIyQzcwLjI5MzkgNzYuOTEyMiA2OC43MDUzIDc1LjEzNDIgNjguNzA1MyA3Mi4zMTRDNjguNzA1MyA3MS41NzgzIDY4LjgyNzUgNzAuNzgxMiA2OS4wNzE5IDY5LjkyMjlDNjUuNTg5MyA3NS44Njk5IDU4Ljg2ODUgODEuMzg3OCA1Mi41NzU0IDgxLjM4NzhDNDcuOTkzIDgxLjM4NzggNDUuNjcxMyA3OC41MDYzIDQ1LjY3MTMgNzQuNDU5OEM0NS42NzEzIDcyLjk4ODQgNDUuOTc2OCA3MS40NTU2IDQ2LjUyNjcgNjkuOTIyOVpNODMuNjc2MSA0Mi41Nzk0QzgzLjY3NjEgNDYuMTcwNCA4MS41NTc1IDQ3Ljk2NTggNzkuMTg3NSA0Ny45NjU4Qzc2Ljc4MTYgNDcuOTY1OCA3NC42OTg5IDQ2LjE3MDQgNzQuNjk4OSA0Mi41Nzk0Qzc0LjY5ODkgMzguOTg4NSA3Ni43ODE2IDM3LjE5MzEgNzkuMTg3NSAzNy4xOTMxQzgxLjU1NzUgMzcuMTkzMSA4My42NzYxIDM4Ljk4ODUgODMuNjc2MSA0Mi41Nzk0Wk03MC4yMTAzIDQyLjU3OTVDNzAuMjEwMyA0Ni4xNzA0IDY4LjA5MTYgNDcuOTY1OCA2NS43MjE2IDQ3Ljk2NThDNjMuMzE1NyA0Ny45NjU4IDYxLjIzMyA0Ni4xNzA0IDYxLjIzMyA0Mi41Nzk1QzYxLjIzMyAzOC45ODg1IDYzLjMxNTcgMzcuMTkzMSA2NS43MjE2IDM3LjE5MzFDNjguMDkxNiAzNy4xOTMxIDcwLjIxMDMgMzguOTg4NSA3MC4yMTAzIDQyLjU3OTVaIiBmaWxsPSIjRkZGREY4Ii8+Cjwvc3ZnPg==",this.supportedTransactionVersions=new Set(["legacy",0]),this._readyState=typeof window>"u"||typeof document>"u"?Q.Unsupported:Q.NotDetected,this._disconnected=()=>{const t=this._wallet;t&&(t.off("disconnect",this._disconnected),t.off("accountChanged",this._accountChanged),this._wallet=null,this._publicKey=null,this.emit("error",new Dt),this.emit("disconnect"))},this._accountChanged=t=>{const n=this._publicKey;if(n){try{t=new C(t.toBytes())}catch(s){this.emit("error",new tt(s==null?void 0:s.message,s));return}n.equals(t)||(this._publicKey=t,this.emit("connect",t))}},this._connecting=!1,this._wallet=null,this._publicKey=null,this._readyState!==Q.Unsupported&&(Ft()?(this._readyState=Q.Loadable,this.emit("readyStateChange",this._readyState)):mn(()=>{var t,n,s;return(n=(t=window.phantom)==null?void 0:t.solana)!=null&&n.isPhantom||(s=window.solana)!=null&&s.isPhantom?(this._readyState=Q.Installed,this.emit("readyStateChange",this._readyState),!0):!1}))}get publicKey(){return this._publicKey}get connecting(){return this._connecting}get readyState(){return this._readyState}async autoConnect(){this.readyState===Q.Installed&&await this.connect()}async connect(){var e;try{if(this.connected||this.connecting)return;if(this.readyState===Q.Loadable){const s=encodeURIComponent(window.location.href),r=encodeURIComponent(window.location.origin);window.location.href=`https://phantom.app/ul/browse/${s}?ref=${r}`;return}if(this.readyState!==Q.Installed)throw new et;this._connecting=!0;const t=((e=window.phantom)==null?void 0:e.solana)||window.solana;if(!t.isConnected)try{await t.connect()}catch(s){throw new bt(s==null?void 0:s.message,s)}if(!t.publicKey)throw new Oe;let n;try{n=new C(t.publicKey.toBytes())}catch(s){throw new tt(s==null?void 0:s.message,s)}t.on("disconnect",this._disconnected),t.on("accountChanged",this._accountChanged),this._wallet=t,this._publicKey=n,this.emit("connect",n)}catch(t){throw this.emit("error",t),t}finally{this._connecting=!1}}async disconnect(){const e=this._wallet;if(e){e.off("disconnect",this._disconnected),e.off("accountChanged",this._accountChanged),this._wallet=null,this._publicKey=null;try{await e.disconnect()}catch(t){this.emit("error",new pn(t==null?void 0:t.message,t))}}this.emit("disconnect")}async sendTransaction(e,t,n={}){try{const s=this._wallet;if(!s)throw new te;try{const{signers:r,...o}=n;De(e)?r!=null&&r.length&&e.sign(r):(e=await this.prepareTransaction(e,t,o),r!=null&&r.length&&e.partialSign(...r)),o.preflightCommitment=o.preflightCommitment||t.commitment;const{signature:u}=await s.signAndSendTransaction(e,o);return u}catch(r){throw r instanceof ce?r:new Ce(r==null?void 0:r.message,r)}}catch(s){throw this.emit("error",s),s}}async signTransaction(e){try{const t=this._wallet;if(!t)throw new te;try{return await t.signTransaction(e)||e}catch(n){throw new Ie(n==null?void 0:n.message,n)}}catch(t){throw this.emit("error",t),t}}async signAllTransactions(e){try{const t=this._wallet;if(!t)throw new te;try{return await t.signAllTransactions(e)||e}catch(n){throw new Ie(n==null?void 0:n.message,n)}}catch(t){throw this.emit("error",t),t}}async signMessage(e){try{const t=this._wallet;if(!t)throw new te;try{const{signature:n}=await t.signMessage(e);return n}catch(n){throw new Mn(n==null?void 0:n.message,n)}}catch(t){throw this.emit("error",t),t}}}const _o="data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjMxIiB2aWV3Qm94PSIwIDAgMzEgMzEiIHdpZHRoPSIzMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PGxpbmVhckdyYWRpZW50IGlkPSJhIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjIwLjI1IiB4Mj0iMjYuNTcxIiB5MT0iMjcuMTczIiB5Mj0iMTkuODU4Ij48c3RvcCBvZmZzZXQ9Ii4wOCIgc3RvcC1jb2xvcj0iIzk5NDVmZiIvPjxzdG9wIG9mZnNldD0iLjMiIHN0b3AtY29sb3I9IiM4NzUyZjMiLz48c3RvcCBvZmZzZXQ9Ii41IiBzdG9wLWNvbG9yPSIjNTQ5N2Q1Ii8+PHN0b3Agb2Zmc2V0PSIuNiIgc3RvcC1jb2xvcj0iIzQzYjRjYSIvPjxzdG9wIG9mZnNldD0iLjcyIiBzdG9wLWNvbG9yPSIjMjhlMGI5Ii8+PHN0b3Agb2Zmc2V0PSIuOTciIHN0b3AtY29sb3I9IiMxOWZiOWIiLz48L2xpbmVhckdyYWRpZW50PjxnIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iLjA5NCI+PHBhdGggZD0ibTI2LjEwOSAzLjY0My05LjM2OSA2Ljk1OSAxLjczMy00LjEwNSA3LjYzNy0yLjg1M3oiIGZpbGw9IiNlMjc2MWIiIHN0cm9rZT0iI2UyNzYxYiIvPjxnIGZpbGw9IiNlNDc2MWIiIHN0cm9rZT0iI2U0NzYxYiI+PHBhdGggZD0ibTQuNDgxIDMuNjQzIDkuMjk0IDcuMDI0LTEuNjQ4LTQuMTcxem0xOC4yNTggMTYuMTMtMi40OTUgMy44MjMgNS4zMzkgMS40NjkgMS41MzUtNS4yMDctNC4zNzgtLjA4NXptLTE5LjI0Ny4wODUgMS41MjUgNS4yMDcgNS4zMzktMS40NjktMi40OTUtMy44MjN6Ii8+PHBhdGggZD0ibTEwLjA1NSAxMy4zMTMtMS40ODggMi4yNTEgNS4zMDEuMjM1LS4xODgtNS42OTd6bTEwLjQ4IDAtMy42NzItMy4yNzctLjEyMiA1Ljc2MyA1LjI5Mi0uMjM1LTEuNDk3LTIuMjUxem0tMTAuMTc4IDEwLjI4MyAzLjE4My0xLjU1NC0yLjc0OS0yLjE0Ny0uNDMzIDMuNzAxem02LjY5NS0xLjU1NCAzLjE5MiAxLjU1NC0uNDQzLTMuNzAxeiIvPjwvZz48cGF0aCBkPSJtMjAuMjQ0IDIzLjU5Ni0zLjE5Mi0xLjU1NC4yNTQgMi4wODEtLjAyOC44NzZ6bS05Ljg4NyAwIDIuOTY2IDEuNDAzLS4wMTktLjg3Ni4yMzUtMi4wODEtMy4xODMgMS41NTR6IiBmaWxsPSIjZDdjMWIzIiBzdHJva2U9IiNkN2MxYjMiLz48cGF0aCBkPSJtMTMuMzY5IDE4LjUyMS0yLjY1NS0uNzgxIDEuODc0LS44NTd6bTMuODUxIDAgLjc4MS0xLjYzOCAxLjg4My44NTctMi42NjUuNzgxeiIgZmlsbD0iIzIzMzQ0NyIgc3Ryb2tlPSIjMjMzNDQ3Ii8+PHBhdGggZD0ibTEwLjM1NyAyMy41OTYuNDUyLTMuODIzLTIuOTQ3LjA4NXptOS40MzUtMy44MjMuNDUyIDMuODIzIDIuNDk1LTMuNzM4em0yLjI0MS00LjIwOS01LjI5Mi4yMzUuNDkgMi43MjEuNzgyLTEuNjM4IDEuODgzLjg1N3ptLTExLjMxOCAyLjE3NSAxLjg4My0uODU3Ljc3MiAxLjYzOC40OTktMi43MjEtNS4zMDEtLjIzNXoiIGZpbGw9IiNjZDYxMTYiIHN0cm9rZT0iI2NkNjExNiIvPjxwYXRoIGQ9Im04LjU2NyAxNS41NjQgMi4yMjIgNC4zMzEtLjA3NS0yLjE1NnptMTEuMzI4IDIuMTc1LS4wOTQgMi4xNTYgMi4yMzItNC4zMzEtMi4xMzcgMi4xNzV6bS02LjAyNi0xLjk0LS40OTkgMi43MjEuNjIxIDMuMjExLjE0MS00LjIyOC0uMjY0LTEuNzA0em0yLjg3MiAwLS4yNTQgMS42OTUuMTEzIDQuMjM3LjYzMS0zLjIxMXoiIGZpbGw9IiNlNDc1MWYiIHN0cm9rZT0iI2U0NzUxZiIvPjxwYXRoIGQ9Im0xNy4yMyAxOC41Mi0uNjMxIDMuMjExLjQ1Mi4zMTEgMi43NS0yLjE0Ny4wOTQtMi4xNTZ6bS02LjUxNi0uNzgxLjA3NSAyLjE1NiAyLjc1IDIuMTQ3LjQ1Mi0uMzExLS42MjItMy4yMTF6IiBmaWxsPSIjZjY4NTFiIiBzdHJva2U9IiNmNjg1MWIiLz48cGF0aCBkPSJtMTcuMjc3IDI0Ljk5OS4wMjgtLjg3Ni0uMjM1LS4yMDdoLTMuNTVsLS4yMTcuMjA3LjAxOS44NzYtMi45NjYtMS40MDMgMS4wMzYuODQ4IDIuMSAxLjQ1OWgzLjYwNmwyLjEwOS0xLjQ1OSAxLjAzNi0uODQ4eiIgZmlsbD0iI2MwYWQ5ZSIgc3Ryb2tlPSIjYzBhZDllIi8+PHBhdGggZD0ibTE3LjA1MSAyMi4wNDItLjQ1Mi0uMzExaC0yLjYwOGwtLjQ1Mi4zMTEtLjIzNSAyLjA4MS4yMTctLjIwN2gzLjU1bC4yMzUuMjA3LS4yNTQtMi4wODF6IiBmaWxsPSIjMTYxNjE2IiBzdHJva2U9IiMxNjE2MTYiLz48cGF0aCBkPSJtMjYuNTA1IDExLjA1My44LTMuODQyLTEuMTk2LTMuNTY5LTkuMDU4IDYuNzIzIDMuNDg0IDIuOTQ3IDQuOTI1IDEuNDQxIDEuMDkyLTEuMjcxLS40NzEtLjMzOS43NTMtLjY4Ny0uNTg0LS40NTIuNzUzLS41NzQtLjQ5OS0uMzc3em0tMjMuMjExLTMuODQxLjggMy44NDItLjUwOC4zNzcuNzUzLjU3NC0uNTc0LjQ1Mi43NTMuNjg3LS40NzEuMzM5IDEuMDgzIDEuMjcxIDQuOTI1LTEuNDQxIDMuNDg0LTIuOTQ3LTkuMDU5LTYuNzIzeiIgZmlsbD0iIzc2M2QxNiIgc3Ryb2tlPSIjNzYzZDE2Ii8+PHBhdGggZD0ibTI1LjQ2IDE0Ljc1NC00LjkyNS0xLjQ0MSAxLjQ5NyAyLjI1MS0yLjIzMiA0LjMzMSAyLjkzOC0uMDM4aDQuMzc4bC0xLjY1Ny01LjEwNHptLTE1LjQwNS0xLjQ0MS00LjkyNSAxLjQ0MS0xLjYzOCA1LjEwNGg0LjM2OWwyLjkyOC4wMzgtMi4yMjItNC4zMzEgMS40ODgtMi4yNTF6bTYuNjg1IDIuNDg2LjMxMS01LjQzMyAxLjQzMS0zLjg3aC02LjM1NmwxLjQxMyAzLjg3LjMyOSA1LjQzMy4xMTMgMS43MTQuMDA5IDQuMjE5aDIuNjFsLjAxOS00LjIxOS4xMjItMS43MTR6IiBmaWxsPSIjZjY4NTFiIiBzdHJva2U9IiNmNjg1MWIiLz48L2c+PGNpcmNsZSBjeD0iMjMuNSIgY3k9IjIzLjUiIGZpbGw9IiMwMDAiIHI9IjYuNSIvPjxwYXRoIGQ9Im0yNy40NzMgMjUuNTQ1LTEuMzEgMS4zNjhjLS4wMjkuMDMtLjA2My4wNTMtLjEwMS4wN2EuMzEuMzEgMCAwIDEgLS4xMjEuMDI0aC02LjIwOWMtLjAzIDAtLjA1OS0uMDA4LS4wODMtLjAyNGEuMTUuMTUgMCAwIDEgLS4wNTYtLjA2NWMtLjAxMi0uMDI2LS4wMTUtLjA1Ni0uMDEtLjA4NHMuMDE4LS4wNTUuMDM5LS4wNzZsMS4zMTEtMS4zNjhjLjAyOC0uMDMuMDYzLS4wNTMuMTAxLS4wNjlhLjMxLjMxIDAgMCAxIC4xMjEtLjAyNWg2LjIwOGMuMDMgMCAuMDU5LjAwOC4wODMuMDI0YS4xNS4xNSAwIDAgMSAuMDU2LjA2NWMuMDEyLjAyNi4wMTUuMDU2LjAxLjA4NHMtLjAxOC4wNTUtLjAzOS4wNzZ6bS0xLjMxLTIuNzU2Yy0uMDI5LS4wMy0uMDYzLS4wNTMtLjEwMS0uMDdhLjMxLjMxIDAgMCAwIC0uMTIxLS4wMjRoLTYuMjA5Yy0uMDMgMC0uMDU5LjAwOC0uMDgzLjAyNHMtLjA0NC4wMzgtLjA1Ni4wNjUtLjAxNS4wNTYtLjAxLjA4NC4wMTguMDU1LjAzOS4wNzZsMS4zMTEgMS4zNjhjLjAyOC4wMy4wNjMuMDUzLjEwMS4wNjlhLjMxLjMxIDAgMCAwIC4xMjEuMDI1aDYuMjA4Yy4wMyAwIC4wNTktLjAwOC4wODMtLjAyNGEuMTUuMTUgMCAwIDAgLjA1Ni0uMDY1Yy4wMTItLjAyNi4wMTUtLjA1Ni4wMS0uMDg0cy0uMDE4LS4wNTUtLjAzOS0uMDc2em0tNi40MzEtLjk4M2g2LjIwOWEuMzEuMzEgMCAwIDAgLjEyMS0uMDI0Yy4wMzgtLjAxNi4wNzMtLjA0LjEwMS0uMDdsMS4zMS0xLjM2OGMuMDItLjAyMS4wMzQtLjA0Ny4wMzktLjA3NnMuMDAxLS4wNTgtLjAxLS4wODRhLjE1LjE1IDAgMCAwIC0uMDU2LS4wNjVjLS4wMjUtLjAxNi0uMDU0LS4wMjQtLjA4My0uMDI0aC02LjIwOGEuMzEuMzEgMCAwIDAgLS4xMjEuMDI1Yy0uMDM4LjAxNi0uMDcyLjA0LS4xMDEuMDY5bC0xLjMxIDEuMzY4Yy0uMDIuMDIxLS4wMzQuMDQ3LS4wMzkuMDc2cy0uMDAxLjA1OC4wMS4wODQuMDMxLjA0OS4wNTYuMDY1LjA1NC4wMjQuMDgzLjAyNHoiIGZpbGw9InVybCgjYSkiLz48L3N2Zz4=";var H=function(i,e,t,n){if(t==="a"&&!n)throw new TypeError("Private accessor was defined without a getter");if(typeof e=="function"?i!==e||!n:!e.has(i))throw new TypeError("Cannot read private member from an object whose class did not declare it");return t==="m"?n:t==="a"?n.call(i):n?n.value:e.get(i)},Oo=function(i,e,t,n,s){if(n==="m")throw new TypeError("Private method is not writable");if(n==="a"&&!s)throw new TypeError("Private accessor was defined without a setter");if(typeof e=="function"?i!==e||!s:!e.has(i))throw new TypeError("Cannot write private member to an object whose class did not declare it");return n==="a"?s.call(i,t):s?s.value=t:e.set(i,t),t},pt,Pe,Zt,$t,Jt,de,Xt,Es,Ds,en,tn,nn,sn,rn;class Co{constructor(){pt.add(this),Pe.set(this,{}),Zt.set(this,"1.0.0"),$t.set(this,"MetaMask"),Jt.set(this,_o),de.set(this,null),Xt.set(this,(e,t)=>{var n;return(n=H(this,Pe,"f")[e])!=null&&n.push(t)||(H(this,Pe,"f")[e]=[t]),()=>H(this,pt,"m",Ds).call(this,e,t)}),en.set(this,async()=>{if(!H(this,de,"f")){let e;try{e=(await Jn(async()=>{const{default:t}=await import("./@solflare-wallet-CjY9iZv-.js").then(n=>n.i);return{default:t}},__vite__mapDeps([0,1,2,3]))).default}catch{throw new Error("Unable to load Solflare MetaMask SDK")}Oo(this,de,new e,"f"),H(this,de,"f").on("standard_change",t=>H(this,pt,"m",Es).call(this,"change",t))}return this.accounts.length||await H(this,de,"f").connect(),{accounts:this.accounts}}),tn.set(this,async()=>{H(this,de,"f")&&await H(this,de,"f").disconnect()}),nn.set(this,async(...e)=>{if(!H(this,de,"f"))throw new te;return await H(this,de,"f").standardSignAndSendTransaction(...e)}),sn.set(this,async(...e)=>{if(!H(this,de,"f"))throw new te;return await H(this,de,"f").standardSignTransaction(...e)}),rn.set(this,async(...e)=>{if(!H(this,de,"f"))throw new te;return await H(this,de,"f").standardSignMessage(...e)})}get version(){return H(this,Zt,"f")}get name(){return H(this,$t,"f")}get icon(){return H(this,Jt,"f")}get chains(){return[qt,Ts,Ls]}get features(){return{[an]:{version:"1.0.0",connect:H(this,en,"f")},[Wt]:{version:"1.0.0",disconnect:H(this,tn,"f")},[cn]:{version:"1.0.0",on:H(this,Xt,"f")},[Ee]:{version:"1.0.0",supportedTransactionVersions:["legacy",0],signAndSendTransaction:H(this,nn,"f")},[ae]:{version:"1.0.0",supportedTransactionVersions:["legacy",0],signTransaction:H(this,sn,"f")},[qe]:{version:"1.0.0",signMessage:H(this,rn,"f")}}}get accounts(){return H(this,de,"f")?H(this,de,"f").standardAccounts:[]}}Pe=new WeakMap,Zt=new WeakMap,$t=new WeakMap,Jt=new WeakMap,de=new WeakMap,Xt=new WeakMap,en=new WeakMap,tn=new WeakMap,nn=new WeakMap,sn=new WeakMap,rn=new WeakMap,pt=new WeakSet,Es=function(e,...t){var n;(n=H(this,Pe,"f")[e])==null||n.forEach(s=>s.apply(null,t))},Ds=function(e,t){var n;H(this,Pe,"f")[e]=(n=H(this,Pe,"f")[e])==null?void 0:n.filter(s=>t!==s)};let $n=!1;function Ro(){$n||(Bs(new Co),$n=!0)}async function Bo(){const i="solflare-detect-metamask";function e(){window.postMessage({target:"metamask-contentscript",data:{name:"metamask-provider",data:{id:i,jsonrpc:"2.0",method:"wallet_getSnaps"}}},window.location.origin)}function t(n){var r,o;const s=n.data;(s==null?void 0:s.target)==="metamask-inpage"&&((r=s.data)==null?void 0:r.name)==="metamask-provider"&&(((o=s.data.data)==null?void 0:o.id)===i?(window.removeEventListener("message",t),s.data.data.error||Ro()):e())}window.addEventListener("message",t),window.setTimeout(()=>window.removeEventListener("message",t),5e3),e()}const vo="Solflare";class ua extends Sn{constructor(e={}){super(),this.name=vo,this.url="https://solflare.com",this.icon="data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjUwIiB2aWV3Qm94PSIwIDAgNTAgNTAiIHdpZHRoPSI1MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PGxpbmVhckdyYWRpZW50IGlkPSJhIj48c3RvcCBvZmZzZXQ9IjAiIHN0b3AtY29sb3I9IiNmZmMxMGIiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNmYjNmMmUiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0iYiIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSI2LjQ3ODM1IiB4Mj0iMzQuOTEwNyIgeGxpbms6aHJlZj0iI2EiIHkxPSI3LjkyIiB5Mj0iMzMuNjU5MyIvPjxyYWRpYWxHcmFkaWVudCBpZD0iYyIgY3g9IjAiIGN5PSIwIiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDQuOTkyMTg4MzIgMTIuMDYzODc5NjMgLTEyLjE4MTEzNjU1IDUuMDQwNzEwNzQgMjIuNTIwMiAyMC42MTgzKSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHI9IjEiIHhsaW5rOmhyZWY9IiNhIi8+PHBhdGggZD0ibTI1LjE3MDggNDcuOTEwNGMuNTI1IDAgLjk1MDcuNDIxLjk1MDcuOTQwM3MtLjQyNTcuOTQwMi0uOTUwNy45NDAyLS45NTA3LS40MjA5LS45NTA3LS45NDAyLjQyNTctLjk0MDMuOTUwNy0uOTQwM3ptLTEuMDMyOC00NC45MTU2NWMuNDY0Ni4wMzgzNi44Mzk4LjM5MDQuOTAyNy44NDY4MWwxLjEzMDcgOC4yMTU3NGMuMzc5OCAyLjcxNDMgMy42NTM1IDMuODkwNCA1LjY3NDMgMi4wNDU5bDExLjMyOTEtMTAuMzExNThjLjI3MzMtLjI0ODczLjY5ODktLjIzMTQ5Ljk1MDcuMDM4NTEuMjMwOS4yNDc3Mi4yMzc5LjYyNjk3LjAxNjEuODgyNzdsLTkuODc5MSAxMS4zOTU4Yy0xLjgxODcgMi4wOTQyLS40NzY4IDUuMzY0MyAyLjI5NTYgNS41OTc4bDguNzE2OC44NDAzYy40MzQxLjA0MTguNzUxNy40MjM0LjcwOTMuODUyNC0uMDM0OS4zNTM3LS4zMDc0LjYzOTUtLjY2MjguNjk0OWwtOS4xNTk0IDEuNDMwMmMtMi42NTkzLjM2MjUtMy44NjM2IDMuNTExNy0yLjEzMzkgNS41NTc2bDMuMjIgMy43OTYxYy4yNTk0LjMwNTguMjE4OC43NjE1LS4wOTA4IDEuMDE3OC0uMjYyMi4yMTcyLS42NDE5LjIyNTYtLjkxMzguMDIwM2wtMy45Njk0LTIuOTk3OGMtMi4xNDIxLTEuNjEwOS01LjIyOTctLjI0MTctNS40NTYxIDIuNDI0M2wtLjg3NDcgMTAuMzk3NmMtLjAzNjIuNDI5NS0uNDE3OC43NDg3LS44NTI1LjcxMy0uMzY5LS4wMzAzLS42NjcxLS4zMDk3LS43MTcxLS42NzIxbC0xLjM4NzEtMTAuMDQzN2MtLjM3MTctMi43MTQ0LTMuNjQ1NC0zLjg5MDQtNS42NzQzLTIuMDQ1OWwtMTIuMDUxOTUgMTAuOTc0Yy0uMjQ5NDcuMjI3MS0uNjM4MDkuMjExNC0uODY4LS4wMzUtLjIxMDk0LS4yMjYyLS4yMTczNS0uNTcyNC0uMDE0OTMtLjgwNmwxMC41MTgxOC0xMi4xMzg1YzEuODE4Ny0yLjA5NDIuNDg0OS01LjM2NDQtMi4yODc2LTUuNTk3OGwtOC43MTg3Mi0uODQwNWMtLjQzNDEzLS4wNDE4LS43NTE3Mi0uNDIzNS0uNzA5MzYtLjg1MjQuMDM0OTMtLjM1MzcuMzA3MzktLjYzOTQuNjYyNy0uNjk1bDkuMTUzMzgtMS40Mjk5YzIuNjU5NC0uMzYyNSAzLjg3MTgtMy41MTE3IDIuMTQyMS01LjU1NzZsLTIuMTkyLTIuNTg0MWMtLjMyMTctLjM3OTItLjI3MTMtLjk0NDMuMTEyNi0xLjI2MjEuMzI1My0uMjY5NC43OTYzLS4yNzk3IDEuMTMzNC0uMDI0OWwyLjY5MTggMi4wMzQ3YzIuMTQyMSAxLjYxMDkgNS4yMjk3LjI0MTcgNS40NTYxLTIuNDI0M2wuNzI0MS04LjU1OTk4Yy4wNDU3LS41NDA4LjUyNjUtLjk0MjU3IDEuMDczOS0uODk3Mzd6bS0yMy4xODczMyAyMC40Mzk2NWMuNTI1MDQgMCAuOTUwNjcuNDIxLjk1MDY3Ljk0MDNzLS40MjU2My45NDAzLS45NTA2Ny45NDAzYy0uNTI1MDQxIDAtLjk1MDY3LS40MjEtLjk1MDY3LS45NDAzcy40MjU2MjktLjk0MDMuOTUwNjctLjk0MDN6bTQ3LjY3OTczLS45NTQ3Yy41MjUgMCAuOTUwNy40MjEuOTUwNy45NDAzcy0uNDI1Ny45NDAyLS45NTA3Ljk0MDItLjk1MDctLjQyMDktLjk1MDctLjk0MDIuNDI1Ny0uOTQwMy45NTA3LS45NDAzem0tMjQuNjI5Ni0yMi40Nzk3Yy41MjUgMCAuOTUwNi40MjA5NzMuOTUwNi45NDAyNyAwIC41MTkzLS40MjU2Ljk0MDI3LS45NTA2Ljk0MDI3LS41MjUxIDAtLjk1MDctLjQyMDk3LS45NTA3LS45NDAyNyAwLS41MTkyOTcuNDI1Ni0uOTQwMjcuOTUwNy0uOTQwMjd6IiBmaWxsPSJ1cmwoI2IpIi8+PHBhdGggZD0ibTI0LjU3MSAzMi43NzkyYzQuOTU5NiAwIDguOTgwMi0zLjk3NjUgOC45ODAyLTguODgxOSAwLTQuOTA1My00LjAyMDYtOC44ODE5LTguOTgwMi04Ljg4MTlzLTguOTgwMiAzLjk3NjYtOC45ODAyIDguODgxOWMwIDQuOTA1NCA0LjAyMDYgOC44ODE5IDguOTgwMiA4Ljg4MTl6IiBmaWxsPSJ1cmwoI2MpIi8+PC9zdmc+",this.supportedTransactionVersions=new Set(["legacy",0]),this._readyState=typeof window>"u"||typeof document>"u"?Q.Unsupported:Q.Loadable,this._disconnected=()=>{const t=this._wallet;t&&(t.off("disconnect",this._disconnected),this._wallet=null,this._publicKey=null,this.emit("error",new Dt),this.emit("disconnect"))},this._accountChanged=t=>{if(!t)return;const n=this._publicKey;if(n){try{t=new C(t.toBytes())}catch(s){this.emit("error",new tt(s==null?void 0:s.message,s));return}n.equals(t)||(this._publicKey=t,this.emit("connect",t))}},this._connecting=!1,this._publicKey=null,this._wallet=null,this._config=e,this._readyState!==Q.Unsupported&&(mn(()=>{var t;return(t=window.solflare)!=null&&t.isSolflare||window.SolflareApp?(this._readyState=Q.Installed,this.emit("readyStateChange",this._readyState),!0):!1}),Bo())}get publicKey(){return this._publicKey}get connecting(){return this._connecting}get connected(){var e;return!!((e=this._wallet)!=null&&e.connected)}get readyState(){return this._readyState}async autoConnect(){this.readyState===Q.Loadable&&Ft()||await this.connect()}async connect(){try{if(this.connected||this.connecting)return;if(this._readyState!==Q.Loadable&&this._readyState!==Q.Installed)throw new et;if(this.readyState===Q.Loadable&&Ft()){const s=encodeURIComponent(window.location.href),r=encodeURIComponent(window.location.origin);window.location.href=`https://solflare.com/ul/v1/browse/${s}?ref=${r}`;return}let e;try{e=(await Jn(async()=>{const{default:s}=await import("./@solflare-wallet-CjY9iZv-.js").then(r=>r.a);return{default:s}},__vite__mapDeps([0,1,2,3]))).default}catch(s){throw new lo(s==null?void 0:s.message,s)}let t;try{t=new e({network:this._config.network})}catch(s){throw new He(s==null?void 0:s.message,s)}if(this._connecting=!0,!t.connected)try{await t.connect()}catch(s){throw new bt(s==null?void 0:s.message,s)}if(!t.publicKey)throw new bt;let n;try{n=new C(t.publicKey.toBytes())}catch(s){throw new tt(s==null?void 0:s.message,s)}t.on("disconnect",this._disconnected),t.on("accountChanged",this._accountChanged),this._wallet=t,this._publicKey=n,this.emit("connect",n)}catch(e){throw this.emit("error",e),e}finally{this._connecting=!1}}async disconnect(){const e=this._wallet;if(e){e.off("disconnect",this._disconnected),e.off("accountChanged",this._accountChanged),this._wallet=null,this._publicKey=null;try{await e.disconnect()}catch(t){this.emit("error",new pn(t==null?void 0:t.message,t))}}this.emit("disconnect")}async sendTransaction(e,t,n={}){try{const s=this._wallet;if(!s)throw new te;try{const{signers:r,...o}=n;return De(e)?r!=null&&r.length&&e.sign(r):(e=await this.prepareTransaction(e,t,o),r!=null&&r.length&&e.partialSign(...r)),o.preflightCommitment=o.preflightCommitment||t.commitment,await s.signAndSendTransaction(e,o)}catch(r){throw r instanceof ce?r:new Ce(r==null?void 0:r.message,r)}}catch(s){throw this.emit("error",s),s}}async signTransaction(e){try{const t=this._wallet;if(!t)throw new te;try{return await t.signTransaction(e)||e}catch(n){throw new Ie(n==null?void 0:n.message,n)}}catch(t){throw this.emit("error",t),t}}async signAllTransactions(e){try{const t=this._wallet;if(!t)throw new te;try{return await t.signAllTransactions(e)||e}catch(n){throw new Ie(n==null?void 0:n.message,n)}}catch(t){throw this.emit("error",t),t}}async signMessage(e){try{const t=this._wallet;if(!t)throw new te;try{return await t.signMessage(e,"utf8")}catch(n){throw new Mn(n==null?void 0:n.message,n)}}catch(t){throw this.emit("error",t),t}}}export{sa as B,na as C,aa as M,C as P,Mt as S,Ne as T,as as V,Q as W,St as a,tt as b,ia as c,te as d,et as e,bt as f,Dt as g,Ie as h,Ce as i,Mn as j,Ee as k,ae as l,qe as m,Yn as n,ta as o,ca as p,ua as q,oa as r,ra as u};
