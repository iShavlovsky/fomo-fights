var w=(s=>(s[s.Border=-1]="Border",s[s.Data=0]="Data",s[s.Function=1]="Function",s[s.Position=2]="Position",s[s.Timing=3]="Timing",s[s.Alignment=4]="Alignment",s))(w||{}),D=Object.defineProperty,T=(s,t,e)=>t in s?D(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e,E=(s,t,e)=>(T(s,typeof t!="symbol"?t+"":t,e),e);const Y=[0,1],N=[1,0],C=[2,3],B=[3,2],V={L:Y,M:N,Q:C,H:B},X=/^[0-9]*$/,$=/^[A-Z0-9 $%*+.\/:-]*$/,b="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:",z=1,R=40,_=3,G=3,A=40,H=10,I=[[-1,7,10,15,20,26,18,20,24,30,18,20,24,26,30,22,24,28,30,28,28,28,28,30,30,26,28,30,30,30,30,30,30,30,30,30,30,30,30,30,30],[-1,10,16,26,18,24,16,18,22,22,26,30,22,22,24,24,28,28,26,26,26,26,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28],[-1,13,22,18,26,18,24,18,22,20,24,28,26,24,20,30,24,28,28,26,30,28,30,30,30,30,28,30,30,30,30,30,30,30,30,30,30,30,30,30,30],[-1,17,28,22,16,22,28,26,26,24,28,24,28,22,24,24,30,28,28,26,28,30,24,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30]],v=[[-1,1,1,1,1,1,2,2,2,2,4,4,4,4,4,6,6,6,6,7,8,8,9,9,10,12,12,12,13,14,15,16,17,18,19,19,20,21,22,24,25],[-1,1,1,1,2,2,4,4,4,5,5,5,8,9,9,10,10,11,13,14,16,17,17,18,20,21,23,25,26,28,29,31,33,35,37,38,40,43,45,47,49],[-1,1,1,2,2,4,4,6,6,8,8,8,10,12,16,12,17,16,18,21,20,23,23,25,27,29,34,34,35,38,40,43,45,48,51,53,56,59,62,65,68],[-1,1,1,2,4,4,4,5,6,8,8,11,11,16,16,18,16,19,21,25,25,25,34,30,32,35,37,40,42,45,48,51,54,57,60,63,66,70,74,77,81]];class K{constructor(t,e,n,o){if(this.version=t,this.ecc=e,E(this,"size"),E(this,"mask"),E(this,"modules",[]),E(this,"types",[]),t<z||t>R)throw new RangeError("Version value out of range");if(o<-1||o>7)throw new RangeError("Mask value out of range");this.size=t*4+17;const r=Array.from({length:this.size},()=>!1);for(let a=0;a<this.size;a++)this.modules.push(r.slice()),this.types.push(r.map(()=>0));this.drawFunctionPatterns();const i=this.addEccAndInterleave(n);if(this.drawCodewords(i),o===-1){let a=1e9;for(let l=0;l<8;l++){this.applyMask(l),this.drawFormatBits(l);const h=this.getPenaltyScore();h<a&&(o=l,a=h),this.applyMask(l)}}this.mask=o,this.applyMask(o),this.drawFormatBits(o)}getModule(t,e){return t>=0&&t<this.size&&e>=0&&e<this.size&&this.modules[e][t]}drawFunctionPatterns(){for(let n=0;n<this.size;n++)this.setFunctionModule(6,n,n%2===0,w.Timing),this.setFunctionModule(n,6,n%2===0,w.Timing);this.drawFinderPattern(3,3),this.drawFinderPattern(this.size-4,3),this.drawFinderPattern(3,this.size-4);const t=this.getAlignmentPatternPositions(),e=t.length;for(let n=0;n<e;n++)for(let o=0;o<e;o++)n===0&&o===0||n===0&&o===e-1||n===e-1&&o===0||this.drawAlignmentPattern(t[n],t[o]);this.drawFormatBits(0),this.drawVersion()}drawFormatBits(t){const e=this.ecc[1]<<3|t;let n=e;for(let r=0;r<10;r++)n=n<<1^(n>>>9)*1335;const o=(e<<10|n)^21522;for(let r=0;r<=5;r++)this.setFunctionModule(8,r,d(o,r));this.setFunctionModule(8,7,d(o,6)),this.setFunctionModule(8,8,d(o,7)),this.setFunctionModule(7,8,d(o,8));for(let r=9;r<15;r++)this.setFunctionModule(14-r,8,d(o,r));for(let r=0;r<8;r++)this.setFunctionModule(this.size-1-r,8,d(o,r));for(let r=8;r<15;r++)this.setFunctionModule(8,this.size-15+r,d(o,r));this.setFunctionModule(8,this.size-8,!0)}drawVersion(){if(this.version<7)return;let t=this.version;for(let n=0;n<12;n++)t=t<<1^(t>>>11)*7973;const e=this.version<<12|t;for(let n=0;n<18;n++){const o=d(e,n),r=this.size-11+n%3,i=Math.floor(n/3);this.setFunctionModule(r,i,o),this.setFunctionModule(i,r,o)}}drawFinderPattern(t,e){for(let n=-4;n<=4;n++)for(let o=-4;o<=4;o++){const r=Math.max(Math.abs(o),Math.abs(n)),i=t+o,a=e+n;i>=0&&i<this.size&&a>=0&&a<this.size&&this.setFunctionModule(i,a,r!==2&&r!==4,w.Position)}}drawAlignmentPattern(t,e){for(let n=-2;n<=2;n++)for(let o=-2;o<=2;o++)this.setFunctionModule(t+o,e+n,Math.max(Math.abs(o),Math.abs(n))!==1,w.Alignment)}setFunctionModule(t,e,n,o=w.Function){this.modules[e][t]=n,this.types[e][t]=o}addEccAndInterleave(t){const e=this.version,n=this.ecc;if(t.length!==P(e,n))throw new RangeError("Invalid argument");const o=v[n[0]][e],r=I[n[0]][e],i=Math.floor(y(e)/8),a=o-i%o,l=Math.floor(i/o),h=[],u=et(r);for(let f=0,g=0;f<o;f++){const M=t.slice(g,g+l-r+(f<a?0:1));g+=M.length;const L=nt(M,u);f<a&&M.push(0),h.push(M.concat(L))}const c=[];for(let f=0;f<h[0].length;f++)h.forEach((g,M)=>{(f!==l-r||M>=a)&&c.push(g[f])});return c}drawCodewords(t){if(t.length!==Math.floor(y(this.version)/8))throw new RangeError("Invalid argument");let e=0;for(let n=this.size-1;n>=1;n-=2){n===6&&(n=5);for(let o=0;o<this.size;o++)for(let r=0;r<2;r++){const i=n-r,l=(n+1&2)===0?this.size-1-o:o;!this.types[l][i]&&e<t.length*8&&(this.modules[l][i]=d(t[e>>>3],7-(e&7)),e++)}}}applyMask(t){if(t<0||t>7)throw new RangeError("Mask value out of range");for(let e=0;e<this.size;e++)for(let n=0;n<this.size;n++){let o;switch(t){case 0:o=(n+e)%2===0;break;case 1:o=e%2===0;break;case 2:o=n%3===0;break;case 3:o=(n+e)%3===0;break;case 4:o=(Math.floor(n/3)+Math.floor(e/2))%2===0;break;case 5:o=n*e%2+n*e%3===0;break;case 6:o=(n*e%2+n*e%3)%2===0;break;case 7:o=((n+e)%2+n*e%3)%2===0;break;default:throw new Error("Unreachable")}!this.types[e][n]&&o&&(this.modules[e][n]=!this.modules[e][n])}}getPenaltyScore(){let t=0;for(let r=0;r<this.size;r++){let i=!1,a=0;const l=[0,0,0,0,0,0,0];for(let h=0;h<this.size;h++)this.modules[r][h]===i?(a++,a===5?t+=_:a>5&&t++):(this.finderPenaltyAddHistory(a,l),i||(t+=this.finderPenaltyCountPatterns(l)*A),i=this.modules[r][h],a=1);t+=this.finderPenaltyTerminateAndCount(i,a,l)*A}for(let r=0;r<this.size;r++){let i=!1,a=0;const l=[0,0,0,0,0,0,0];for(let h=0;h<this.size;h++)this.modules[h][r]===i?(a++,a===5?t+=_:a>5&&t++):(this.finderPenaltyAddHistory(a,l),i||(t+=this.finderPenaltyCountPatterns(l)*A),i=this.modules[h][r],a=1);t+=this.finderPenaltyTerminateAndCount(i,a,l)*A}for(let r=0;r<this.size-1;r++)for(let i=0;i<this.size-1;i++){const a=this.modules[r][i];a===this.modules[r][i+1]&&a===this.modules[r+1][i]&&a===this.modules[r+1][i+1]&&(t+=G)}let e=0;for(const r of this.modules)e=r.reduce((i,a)=>i+(a?1:0),e);const n=this.size*this.size,o=Math.ceil(Math.abs(e*20-n*10)/n)-1;return t+=o*H,t}getAlignmentPatternPositions(){if(this.version===1)return[];{const t=Math.floor(this.version/7)+2,e=this.version===32?26:Math.ceil((this.version*4+4)/(t*2-2))*2,n=[6];for(let o=this.size-7;n.length<t;o-=e)n.splice(1,0,o);return n}}finderPenaltyCountPatterns(t){const e=t[1],n=e>0&&t[2]===e&&t[3]===e*3&&t[4]===e&&t[5]===e;return(n&&t[0]>=e*4&&t[6]>=e?1:0)+(n&&t[6]>=e*4&&t[0]>=e?1:0)}finderPenaltyTerminateAndCount(t,e,n){return t&&(this.finderPenaltyAddHistory(e,n),e=0),e+=this.size,this.finderPenaltyAddHistory(e,n),this.finderPenaltyCountPatterns(n)}finderPenaltyAddHistory(t,e){e[0]===0&&(t+=this.size),e.pop(),e.unshift(t)}}function m(s,t,e){if(t<0||t>31||s>>>t)throw new RangeError("Value out of range");for(let n=t-1;n>=0;n--)e.push(s>>>n&1)}function d(s,t){return(s>>>t&1)!==0}class F{constructor(t,e,n){if(this.mode=t,this.numChars=e,this.bitData=n,e<0)throw new RangeError("Invalid argument");this.bitData=n.slice()}getData(){return this.bitData.slice()}}const W=[1,10,12,14],j=[2,9,11,13],q=[4,8,16,16];function O(s,t){return s[Math.floor((t+7)/17)+1]}function S(s){const t=[];for(const e of s)m(e,8,t);return new F(q,s.length,t)}function Z(s){if(!k(s))throw new RangeError("String contains non-numeric characters");const t=[];for(let e=0;e<s.length;){const n=Math.min(s.length-e,3);m(Number.parseInt(s.substring(e,e+n),10),n*3+1,t),e+=n}return new F(W,s.length,t)}function J(s){if(!U(s))throw new RangeError("String contains unencodable characters in alphanumeric mode");const t=[];let e;for(e=0;e+2<=s.length;e+=2){let n=b.indexOf(s.charAt(e))*45;n+=b.indexOf(s.charAt(e+1)),m(n,11,t)}return e<s.length&&m(b.indexOf(s.charAt(e)),6,t),new F(j,s.length,t)}function x(s){return s===""?[]:k(s)?[Z(s)]:U(s)?[J(s)]:[S(tt(s))]}function k(s){return X.test(s)}function U(s){return $.test(s)}function Q(s,t){let e=0;for(const n of s){const o=O(n.mode,t);if(n.numChars>=1<<o)return Number.POSITIVE_INFINITY;e+=4+o+n.bitData.length}return e}function tt(s){s=encodeURI(s);const t=[];for(let e=0;e<s.length;e++)s.charAt(e)!=="%"?t.push(s.charCodeAt(e)):(t.push(Number.parseInt(s.substring(e+1,e+3),16)),e+=2);return t}function y(s){if(s<z||s>R)throw new RangeError("Version number out of range");let t=(16*s+128)*s+64;if(s>=2){const e=Math.floor(s/7)+2;t-=(25*e-10)*e-55,s>=7&&(t-=36)}return t}function P(s,t){return Math.floor(y(s)/8)-I[t[0]][s]*v[t[0]][s]}function et(s){if(s<1||s>255)throw new RangeError("Degree out of range");const t=[];for(let n=0;n<s-1;n++)t.push(0);t.push(1);let e=1;for(let n=0;n<s;n++){for(let o=0;o<t.length;o++)t[o]=p(t[o],e),o+1<t.length&&(t[o]^=t[o+1]);e=p(e,2)}return t}function nt(s,t){const e=t.map(n=>0);for(const n of s){const o=n^e.shift();e.push(0),t.forEach((r,i)=>e[i]^=p(r,o))}return e}function p(s,t){if(s>>>8||t>>>8)throw new RangeError("Byte out of range");let e=0;for(let n=7;n>=0;n--)e=e<<1^(e>>>7)*285,e^=(t>>>n&1)*s;return e}function st(s,t,e=1,n=40,o=-1,r=!0){if(!(z<=e&&e<=n&&n<=R)||o<-1||o>7)throw new RangeError("Invalid value");let i,a;for(i=e;;i++){const c=P(i,t)*8,f=Q(s,i);if(f<=c){a=f;break}if(i>=n)throw new RangeError("Data too long")}for(const c of[N,C,B])r&&a<=P(i,c)*8&&(t=c);const l=[];for(const c of s){m(c.mode[0],4,l),m(c.numChars,O(c.mode,i),l);for(const f of c.getData())l.push(f)}const h=P(i,t)*8;m(0,Math.min(4,h-l.length),l),m(0,(8-l.length%8)%8,l);for(let c=236;l.length<h;c^=253)m(c,8,l);const u=Array.from({length:Math.ceil(l.length/8)},()=>0);return l.forEach((c,f)=>u[f>>>3]|=c<<7-(f&7)),new K(i,t,u,o)}function rt(s,t){var c;const{ecc:e="L",boostEcc:n=!1,minVersion:o=1,maxVersion:r=40,maskPattern:i=-1,border:a=1}=t||{},l=typeof s=="string"?x(s):Array.isArray(s)?[S(s)]:void 0;if(!l)throw new Error(`uqr only supports encoding string and binary data, but got: ${typeof s}`);const h=st(l,V[e],o,r,i,n),u=ot({version:h.version,maskPattern:h.mask,size:h.size,data:h.modules,types:h.types},a);return t!=null&&t.invert&&(u.data=u.data.map(f=>f.map(g=>!g))),(c=t==null?void 0:t.onEncoded)==null||c.call(t,u),u}function ot(s,t=1){if(!t)return s;const{size:e}=s,n=e+t*2;s.size=n,s.data.forEach(r=>{for(let i=0;i<t;i++)r.unshift(!1),r.push(!1)});for(let r=0;r<t;r++)s.data.unshift(Array.from({length:n},i=>!1)),s.data.push(Array.from({length:n},i=>!1));const o=w.Border;s.types.forEach(r=>{for(let i=0;i<t;i++)r.unshift(o),r.push(o)});for(let r=0;r<t;r++)s.types.unshift(Array.from({length:n},i=>o)),s.types.push(Array.from({length:n},i=>o));return s}export{rt as e};
